/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*- */
// vim: ft=cpp:expandtab:ts=8:sw=4:softtabstop=4:
#ifndef LOG_HEADER_H
#define  LOG_HEADER_H
/* Do not edit this file.  This code generated by logformat.c.  Copyright (c) 2007-2013 Tokutek Inc.    */
#ident "Copyright (c) 2007-2013 Tokutek Inc.  All rights reserved."
#include <ft/ft-internal.h>
#include <ft/memarena.h>
enum lt_cmd {
    LT_begin_checkpoint = 'x',
    LT_end_checkpoint   = 'X',
    LT_fassociate       = 'f',
    LT_xstillopen       = 's',
    LT_xstillopenprepared = 'p',
    LT_xbegin           = 'b',
    LT_xcommit          = 'C',
    LT_xprepare         = 'P',
    LT_xabort           = 'q',
    LT_fcreate          = 'F',
    LT_fopen            = 'O',
    LT_fclose           = 'e',
    LT_fdelete          = 'U',
    LT_enq_insert       = 'I',
    LT_enq_insert_no_overwrite = 'i',
    LT_enq_delete_any   = 'E',
    LT_enq_insert_multiple = 'm',
    LT_enq_delete_multiple = 'M',
    LT_comment          = 'T',
    LT_enq_delete_multi = 'Z',
    LT_enq_unbound_insert = 'G',
    LT_sync_unbound_insert = 'S',
    LT_shutdown_up_to_19 = 'Q',
    LT_shutdown         = '0',
    LT_load             = 'l',
    LT_hot_index        = 'h',
    LT_enq_update       = 'u',
    LT_enq_updatebroadcast = 'B',
    LT_change_fdescriptor = 'D'
};

enum rt_cmd {
    RT_fdelete          = 'U',
    RT_fcreate          = 'F',
    RT_cmdinsert        = 'i',
    RT_cmdseqinsert     = 'g',
    RT_cmddelete        = 'd',
    RT_cmddeletemulti   = 'Z',
    RT_rollinclude      = 'r',
    RT_load             = 'l',
    RT_hot_index        = 'h',
    RT_dictionary_redirect = 'R',
    RT_cmdupdate        = 'u',
    RT_cmdupdatebroadcast = 'B',
    RT_change_fdescriptor = 'D'
};

struct logtype_begin_checkpoint {
  LSN              lsn;
  uint64_t         timestamp;
  TXNID            last_xid;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_end_checkpoint {
  LSN              lsn;
  LSN              lsn_begin_checkpoint;
  uint64_t         timestamp;
  uint32_t         num_fassociate_entries;
  uint32_t         num_xstillopen_entries;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_fassociate {
  LSN              lsn;
  FILENUM          filenum;
  uint32_t         treeflags;
  BYTESTRING       iname;
  uint8_t          unlink_on_close;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_xstillopen {
  LSN              lsn;
  TXNID_PAIR       xid;
  TXNID_PAIR       parentxid;
  uint64_t         rollentry_raw_count;
  FILENUMS         open_filenums;
  uint8_t          force_fsync_on_commit;
  uint64_t         num_rollback_nodes;
  uint64_t         num_rollentries;
  BLOCKNUM         spilled_rollback_head;
  BLOCKNUM         spilled_rollback_tail;
  BLOCKNUM         current_rollback;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_xstillopenprepared {
  LSN              lsn;
  TXNID_PAIR       xid;
  XIDP             xa_xid;
  uint64_t         rollentry_raw_count;
  FILENUMS         open_filenums;
  uint8_t          force_fsync_on_commit;
  uint64_t         num_rollback_nodes;
  uint64_t         num_rollentries;
  BLOCKNUM         spilled_rollback_head;
  BLOCKNUM         spilled_rollback_tail;
  BLOCKNUM         current_rollback;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_xbegin {
  LSN              lsn;
  TXNID_PAIR       xid;
  TXNID_PAIR       parentxid;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_xcommit {
  LSN              lsn;
  TXNID_PAIR       xid;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_xprepare {
  LSN              lsn;
  TXNID_PAIR       xid;
  XIDP             xa_xid;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_xabort {
  LSN              lsn;
  TXNID_PAIR       xid;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_fcreate {
  LSN              lsn;
  TXNID_PAIR       xid;
  FILENUM          filenum;
  BYTESTRING       iname;
  uint32_t         mode;
  uint32_t         treeflags;
  uint32_t         nodesize;
  uint32_t         basementnodesize;
  uint32_t         compression_method;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_fopen {
  LSN              lsn;
  BYTESTRING       iname;
  FILENUM          filenum;
  uint32_t         treeflags;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_fclose {
  LSN              lsn;
  BYTESTRING       iname;
  FILENUM          filenum;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_fdelete {
  LSN              lsn;
  TXNID_PAIR       xid;
  FILENUM          filenum;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_enq_insert {
  LSN              lsn;
  FILENUM          filenum;
  TXNID_PAIR       xid;
  BYTESTRING       key;
  BYTESTRING       value;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_enq_insert_no_overwrite {
  LSN              lsn;
  FILENUM          filenum;
  TXNID_PAIR       xid;
  BYTESTRING       key;
  BYTESTRING       value;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_enq_delete_any {
  LSN              lsn;
  FILENUM          filenum;
  TXNID_PAIR       xid;
  BYTESTRING       key;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_enq_insert_multiple {
  LSN              lsn;
  FILENUM          src_filenum;
  FILENUMS         dest_filenums;
  TXNID_PAIR       xid;
  BYTESTRING       src_key;
  BYTESTRING       src_val;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_enq_delete_multiple {
  LSN              lsn;
  FILENUM          src_filenum;
  FILENUMS         dest_filenums;
  TXNID_PAIR       xid;
  BYTESTRING       src_key;
  BYTESTRING       src_val;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_comment {
  LSN              lsn;
  uint64_t         timestamp;
  BYTESTRING       comment;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_enq_delete_multi {
  LSN              lsn;
  FILENUM          filenum;
  TXNID_PAIR       xid;
  BYTESTRING       min_key;
  BYTESTRING       max_key;
  bool             is_right_excl;
  uint32_t         pm_status;
  bool             is_resetting_op;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_enq_unbound_insert {
  LSN              lsn;
  FILENUM          filenum;
  TXNID_PAIR       xid;
  BYTESTRING       key;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_sync_unbound_insert {
  LSN              lsn;
  MSN              msn_in_tree;
  LSN              lsn_of_enq;
  DISKOFF          offset;
  DISKOFF          size;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_shutdown_up_to_19 {
  LSN              lsn;
  uint64_t         timestamp;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_shutdown {
  LSN              lsn;
  uint64_t         timestamp;
  TXNID            last_xid;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_load {
  LSN              lsn;
  TXNID_PAIR       xid;
  FILENUM          old_filenum;
  BYTESTRING       new_iname;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_hot_index {
  LSN              lsn;
  TXNID_PAIR       xid;
  FILENUMS         hot_index_filenums;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_enq_update {
  LSN              lsn;
  FILENUM          filenum;
  TXNID_PAIR       xid;
  BYTESTRING       key;
  BYTESTRING       extra;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_enq_updatebroadcast {
  LSN              lsn;
  FILENUM          filenum;
  TXNID_PAIR       xid;
  BYTESTRING       extra;
  bool             is_resetting_op;
  uint32_t         crc;
  uint32_t         len;
};
struct logtype_change_fdescriptor {
  LSN              lsn;
  FILENUM          filenum;
  TXNID_PAIR       xid;
  BYTESTRING       old_descriptor;
  BYTESTRING       new_descriptor;
  bool             update_cmp_descriptor;
  uint32_t         crc;
  uint32_t         len;
};
struct rolltype_fdelete {
  FILENUM          filenum;
};
int toku_rollback_fdelete (FILENUM filenum,TOKUTXN txn, LSN oplsn);
int toku_commit_fdelete (FILENUM filenum,TOKUTXN txn, LSN oplsn);
struct rolltype_fcreate {
  FILENUM          filenum;
  BYTESTRING       iname;
};
int toku_rollback_fcreate (FILENUM filenum,BYTESTRING iname,TOKUTXN txn, LSN oplsn);
int toku_commit_fcreate (FILENUM filenum,BYTESTRING iname,TOKUTXN txn, LSN oplsn);
struct rolltype_cmdinsert {
  FILENUM          filenum;
  BYTESTRING       key;
};
int toku_rollback_cmdinsert (FILENUM filenum,BYTESTRING key,TOKUTXN txn, LSN oplsn);
int toku_commit_cmdinsert (FILENUM filenum,BYTESTRING key,TOKUTXN txn, LSN oplsn);
struct rolltype_cmdseqinsert {
  FILENUM          filenum;
  BYTESTRING       key;
};
int toku_rollback_cmdseqinsert (FILENUM filenum,BYTESTRING key,TOKUTXN txn, LSN oplsn);
int toku_commit_cmdseqinsert (FILENUM filenum,BYTESTRING key,TOKUTXN txn, LSN oplsn);
struct rolltype_cmddelete {
  FILENUM          filenum;
  BYTESTRING       key;
};
int toku_rollback_cmddelete (FILENUM filenum,BYTESTRING key,TOKUTXN txn, LSN oplsn);
int toku_commit_cmddelete (FILENUM filenum,BYTESTRING key,TOKUTXN txn, LSN oplsn);
struct rolltype_cmddeletemulti {
  FILENUM          filenum;
  BYTESTRING       min_key;
  BYTESTRING       max_key;
  bool             is_right_excl;
  uint32_t         pm_status;
  bool             is_resetting_op;
};
int toku_rollback_cmddeletemulti (FILENUM filenum,BYTESTRING min_key,BYTESTRING max_key,bool is_right_excl,uint32_t pm_status,bool is_resetting_op,TOKUTXN txn, LSN oplsn);
int toku_commit_cmddeletemulti (FILENUM filenum,BYTESTRING min_key,BYTESTRING max_key,bool is_right_excl,uint32_t pm_status,bool is_resetting_op,TOKUTXN txn, LSN oplsn);
struct rolltype_rollinclude {
  TXNID_PAIR       xid;
  uint64_t         num_nodes;
  BLOCKNUM         spilled_head;
  BLOCKNUM         spilled_tail;
};
int toku_rollback_rollinclude (TXNID_PAIR xid,uint64_t num_nodes,BLOCKNUM spilled_head,BLOCKNUM spilled_tail,TOKUTXN txn, LSN oplsn);
int toku_commit_rollinclude (TXNID_PAIR xid,uint64_t num_nodes,BLOCKNUM spilled_head,BLOCKNUM spilled_tail,TOKUTXN txn, LSN oplsn);
struct rolltype_load {
  FILENUM          old_filenum;
  BYTESTRING       new_iname;
};
int toku_rollback_load (FILENUM old_filenum,BYTESTRING new_iname,TOKUTXN txn, LSN oplsn);
int toku_commit_load (FILENUM old_filenum,BYTESTRING new_iname,TOKUTXN txn, LSN oplsn);
struct rolltype_hot_index {
  FILENUMS         hot_index_filenums;
};
int toku_rollback_hot_index (FILENUMS hot_index_filenums,TOKUTXN txn, LSN oplsn);
int toku_commit_hot_index (FILENUMS hot_index_filenums,TOKUTXN txn, LSN oplsn);
struct rolltype_dictionary_redirect {
  FILENUM          old_filenum;
  FILENUM          new_filenum;
};
int toku_rollback_dictionary_redirect (FILENUM old_filenum,FILENUM new_filenum,TOKUTXN txn, LSN oplsn);
int toku_commit_dictionary_redirect (FILENUM old_filenum,FILENUM new_filenum,TOKUTXN txn, LSN oplsn);
struct rolltype_cmdupdate {
  FILENUM          filenum;
  BYTESTRING       key;
};
int toku_rollback_cmdupdate (FILENUM filenum,BYTESTRING key,TOKUTXN txn, LSN oplsn);
int toku_commit_cmdupdate (FILENUM filenum,BYTESTRING key,TOKUTXN txn, LSN oplsn);
struct rolltype_cmdupdatebroadcast {
  FILENUM          filenum;
  bool             is_resetting_op;
};
int toku_rollback_cmdupdatebroadcast (FILENUM filenum,bool is_resetting_op,TOKUTXN txn, LSN oplsn);
int toku_commit_cmdupdatebroadcast (FILENUM filenum,bool is_resetting_op,TOKUTXN txn, LSN oplsn);
struct rolltype_change_fdescriptor {
  FILENUM          filenum;
  BYTESTRING       old_descriptor;
};
int toku_rollback_change_fdescriptor (FILENUM filenum,BYTESTRING old_descriptor,TOKUTXN txn, LSN oplsn);
int toku_commit_change_fdescriptor (FILENUM filenum,BYTESTRING old_descriptor,TOKUTXN txn, LSN oplsn);
struct log_entry {
  enum lt_cmd cmd;
  union {
    struct logtype_begin_checkpoint begin_checkpoint;
    struct logtype_end_checkpoint end_checkpoint;
    struct logtype_fassociate fassociate;
    struct logtype_xstillopen xstillopen;
    struct logtype_xstillopenprepared xstillopenprepared;
    struct logtype_xbegin xbegin;
    struct logtype_xcommit xcommit;
    struct logtype_xprepare xprepare;
    struct logtype_xabort xabort;
    struct logtype_fcreate fcreate;
    struct logtype_fopen fopen;
    struct logtype_fclose fclose;
    struct logtype_fdelete fdelete;
    struct logtype_enq_insert enq_insert;
    struct logtype_enq_insert_no_overwrite enq_insert_no_overwrite;
    struct logtype_enq_delete_any enq_delete_any;
    struct logtype_enq_insert_multiple enq_insert_multiple;
    struct logtype_enq_delete_multiple enq_delete_multiple;
    struct logtype_comment comment;
    struct logtype_enq_delete_multi enq_delete_multi;
    struct logtype_enq_unbound_insert enq_unbound_insert;
    struct logtype_sync_unbound_insert sync_unbound_insert;
    struct logtype_shutdown_up_to_19 shutdown_up_to_19;
    struct logtype_shutdown shutdown;
    struct logtype_load load;
    struct logtype_hot_index hot_index;
    struct logtype_enq_update enq_update;
    struct logtype_enq_updatebroadcast enq_updatebroadcast;
    struct logtype_change_fdescriptor change_fdescriptor;
  } u;
};
struct roll_entry {
  enum rt_cmd cmd;
  struct roll_entry *prev; /* for in-memory list of log entries.  Threads from newest to oldest. */
  union {
    struct rolltype_fdelete fdelete;
    struct rolltype_fcreate fcreate;
    struct rolltype_cmdinsert cmdinsert;
    struct rolltype_cmdseqinsert cmdseqinsert;
    struct rolltype_cmddelete cmddelete;
    struct rolltype_cmddeletemulti cmddeletemulti;
    struct rolltype_rollinclude rollinclude;
    struct rolltype_load load;
    struct rolltype_hot_index hot_index;
    struct rolltype_dictionary_redirect dictionary_redirect;
    struct rolltype_cmdupdate cmdupdate;
    struct rolltype_cmdupdatebroadcast cmdupdatebroadcast;
    struct rolltype_change_fdescriptor change_fdescriptor;
  } u;
};
#define rolltype_dispatch(s, funprefix) ({ switch((s)->cmd) {\
  case RT_fdelete: funprefix ## fdelete (&(s)->u.fdelete); break;\
  case RT_fcreate: funprefix ## fcreate (&(s)->u.fcreate); break;\
  case RT_cmdinsert: funprefix ## cmdinsert (&(s)->u.cmdinsert); break;\
  case RT_cmdseqinsert: funprefix ## cmdseqinsert (&(s)->u.cmdseqinsert); break;\
  case RT_cmddelete: funprefix ## cmddelete (&(s)->u.cmddelete); break;\
  case RT_cmddeletemulti: funprefix ## cmddeletemulti (&(s)->u.cmddeletemulti); break;\
  case RT_rollinclude: funprefix ## rollinclude (&(s)->u.rollinclude); break;\
  case RT_load: funprefix ## load (&(s)->u.load); break;\
  case RT_hot_index: funprefix ## hot_index (&(s)->u.hot_index); break;\
  case RT_dictionary_redirect: funprefix ## dictionary_redirect (&(s)->u.dictionary_redirect); break;\
  case RT_cmdupdate: funprefix ## cmdupdate (&(s)->u.cmdupdate); break;\
  case RT_cmdupdatebroadcast: funprefix ## cmdupdatebroadcast (&(s)->u.cmdupdatebroadcast); break;\
  case RT_change_fdescriptor: funprefix ## change_fdescriptor (&(s)->u.change_fdescriptor); break;\
 }})
#define logtype_dispatch_assign(s, funprefix, var, ...) do { switch((s)->cmd) {\
  case LT_begin_checkpoint: var = funprefix ## begin_checkpoint (&(s)->u.begin_checkpoint, __VA_ARGS__); break;\
  case LT_end_checkpoint: var = funprefix ## end_checkpoint (&(s)->u.end_checkpoint, __VA_ARGS__); break;\
  case LT_fassociate: var = funprefix ## fassociate (&(s)->u.fassociate, __VA_ARGS__); break;\
  case LT_xstillopen: var = funprefix ## xstillopen (&(s)->u.xstillopen, __VA_ARGS__); break;\
  case LT_xstillopenprepared: var = funprefix ## xstillopenprepared (&(s)->u.xstillopenprepared, __VA_ARGS__); break;\
  case LT_xbegin: var = funprefix ## xbegin (&(s)->u.xbegin, __VA_ARGS__); break;\
  case LT_xcommit: var = funprefix ## xcommit (&(s)->u.xcommit, __VA_ARGS__); break;\
  case LT_xprepare: var = funprefix ## xprepare (&(s)->u.xprepare, __VA_ARGS__); break;\
  case LT_xabort: var = funprefix ## xabort (&(s)->u.xabort, __VA_ARGS__); break;\
  case LT_fcreate: var = funprefix ## fcreate (&(s)->u.fcreate, __VA_ARGS__); break;\
  case LT_fopen: var = funprefix ## fopen (&(s)->u.fopen, __VA_ARGS__); break;\
  case LT_fclose: var = funprefix ## fclose (&(s)->u.fclose, __VA_ARGS__); break;\
  case LT_fdelete: var = funprefix ## fdelete (&(s)->u.fdelete, __VA_ARGS__); break;\
  case LT_enq_insert: var = funprefix ## enq_insert (&(s)->u.enq_insert, __VA_ARGS__); break;\
  case LT_enq_insert_no_overwrite: var = funprefix ## enq_insert_no_overwrite (&(s)->u.enq_insert_no_overwrite, __VA_ARGS__); break;\
  case LT_enq_delete_any: var = funprefix ## enq_delete_any (&(s)->u.enq_delete_any, __VA_ARGS__); break;\
  case LT_enq_insert_multiple: var = funprefix ## enq_insert_multiple (&(s)->u.enq_insert_multiple, __VA_ARGS__); break;\
  case LT_enq_delete_multiple: var = funprefix ## enq_delete_multiple (&(s)->u.enq_delete_multiple, __VA_ARGS__); break;\
  case LT_comment: var = funprefix ## comment (&(s)->u.comment, __VA_ARGS__); break;\
  case LT_enq_delete_multi: var = funprefix ## enq_delete_multi (&(s)->u.enq_delete_multi, __VA_ARGS__); break;\
  case LT_enq_unbound_insert: var = funprefix ## enq_unbound_insert (&(s)->u.enq_unbound_insert, __VA_ARGS__); break;\
  case LT_sync_unbound_insert: var = funprefix ## sync_unbound_insert (&(s)->u.sync_unbound_insert, __VA_ARGS__); break;\
  case LT_shutdown_up_to_19: var = funprefix ## shutdown_up_to_19 (&(s)->u.shutdown_up_to_19, __VA_ARGS__); break;\
  case LT_shutdown: var = funprefix ## shutdown (&(s)->u.shutdown, __VA_ARGS__); break;\
  case LT_load: var = funprefix ## load (&(s)->u.load, __VA_ARGS__); break;\
  case LT_hot_index: var = funprefix ## hot_index (&(s)->u.hot_index, __VA_ARGS__); break;\
  case LT_enq_update: var = funprefix ## enq_update (&(s)->u.enq_update, __VA_ARGS__); break;\
  case LT_enq_updatebroadcast: var = funprefix ## enq_updatebroadcast (&(s)->u.enq_updatebroadcast, __VA_ARGS__); break;\
  case LT_change_fdescriptor: var = funprefix ## change_fdescriptor (&(s)->u.change_fdescriptor, __VA_ARGS__); break;\
 }} while (0)
#define rolltype_dispatch_assign(s, funprefix, var, ...) do { \
  switch((s)->cmd) {\
  case RT_fdelete: var = funprefix ## fdelete ((s)->u.fdelete.filenum, __VA_ARGS__); break;\
  case RT_fcreate: var = funprefix ## fcreate ((s)->u.fcreate.filenum,(s)->u.fcreate.iname, __VA_ARGS__); break;\
  case RT_cmdinsert: var = funprefix ## cmdinsert ((s)->u.cmdinsert.filenum,(s)->u.cmdinsert.key, __VA_ARGS__); break;\
  case RT_cmdseqinsert: var = funprefix ## cmdseqinsert ((s)->u.cmdseqinsert.filenum,(s)->u.cmdseqinsert.key, __VA_ARGS__); break;\
  case RT_cmddelete: var = funprefix ## cmddelete ((s)->u.cmddelete.filenum,(s)->u.cmddelete.key, __VA_ARGS__); break;\
  case RT_cmddeletemulti: var = funprefix ## cmddeletemulti ((s)->u.cmddeletemulti.filenum,(s)->u.cmddeletemulti.min_key,(s)->u.cmddeletemulti.max_key,(s)->u.cmddeletemulti.is_right_excl,(s)->u.cmddeletemulti.pm_status,(s)->u.cmddeletemulti.is_resetting_op, __VA_ARGS__); break;\
  case RT_rollinclude: var = funprefix ## rollinclude ((s)->u.rollinclude.xid,(s)->u.rollinclude.num_nodes,(s)->u.rollinclude.spilled_head,(s)->u.rollinclude.spilled_tail, __VA_ARGS__); break;\
  case RT_load: var = funprefix ## load ((s)->u.load.old_filenum,(s)->u.load.new_iname, __VA_ARGS__); break;\
  case RT_hot_index: var = funprefix ## hot_index ((s)->u.hot_index.hot_index_filenums, __VA_ARGS__); break;\
  case RT_dictionary_redirect: var = funprefix ## dictionary_redirect ((s)->u.dictionary_redirect.old_filenum,(s)->u.dictionary_redirect.new_filenum, __VA_ARGS__); break;\
  case RT_cmdupdate: var = funprefix ## cmdupdate ((s)->u.cmdupdate.filenum,(s)->u.cmdupdate.key, __VA_ARGS__); break;\
  case RT_cmdupdatebroadcast: var = funprefix ## cmdupdatebroadcast ((s)->u.cmdupdatebroadcast.filenum,(s)->u.cmdupdatebroadcast.is_resetting_op, __VA_ARGS__); break;\
  case RT_change_fdescriptor: var = funprefix ## change_fdescriptor ((s)->u.change_fdescriptor.filenum,(s)->u.change_fdescriptor.old_descriptor, __VA_ARGS__); break;\
  default: assert(0);} } while (0)
#define logtype_dispatch_args(s, funprefix, ...) do { switch((s)->cmd) {\
  case LT_begin_checkpoint: funprefix ## begin_checkpoint ((s)->u.begin_checkpoint.lsn,(s)->u.begin_checkpoint.timestamp,(s)->u.begin_checkpoint.last_xid, __VA_ARGS__); break;\
  case LT_end_checkpoint: funprefix ## end_checkpoint ((s)->u.end_checkpoint.lsn,(s)->u.end_checkpoint.lsn_begin_checkpoint,(s)->u.end_checkpoint.timestamp,(s)->u.end_checkpoint.num_fassociate_entries,(s)->u.end_checkpoint.num_xstillopen_entries, __VA_ARGS__); break;\
  case LT_fassociate: funprefix ## fassociate ((s)->u.fassociate.lsn,(s)->u.fassociate.filenum,(s)->u.fassociate.treeflags,(s)->u.fassociate.iname,(s)->u.fassociate.unlink_on_close, __VA_ARGS__); break;\
  case LT_xstillopen: funprefix ## xstillopen ((s)->u.xstillopen.lsn,(s)->u.xstillopen.xid,(s)->u.xstillopen.parentxid,(s)->u.xstillopen.rollentry_raw_count,(s)->u.xstillopen.open_filenums,(s)->u.xstillopen.force_fsync_on_commit,(s)->u.xstillopen.num_rollback_nodes,(s)->u.xstillopen.num_rollentries,(s)->u.xstillopen.spilled_rollback_head,(s)->u.xstillopen.spilled_rollback_tail,(s)->u.xstillopen.current_rollback, __VA_ARGS__); break;\
  case LT_xstillopenprepared: funprefix ## xstillopenprepared ((s)->u.xstillopenprepared.lsn,(s)->u.xstillopenprepared.xid,(s)->u.xstillopenprepared.xa_xid,(s)->u.xstillopenprepared.rollentry_raw_count,(s)->u.xstillopenprepared.open_filenums,(s)->u.xstillopenprepared.force_fsync_on_commit,(s)->u.xstillopenprepared.num_rollback_nodes,(s)->u.xstillopenprepared.num_rollentries,(s)->u.xstillopenprepared.spilled_rollback_head,(s)->u.xstillopenprepared.spilled_rollback_tail,(s)->u.xstillopenprepared.current_rollback, __VA_ARGS__); break;\
  case LT_xbegin: funprefix ## xbegin ((s)->u.xbegin.lsn,(s)->u.xbegin.xid,(s)->u.xbegin.parentxid, __VA_ARGS__); break;\
  case LT_xcommit: funprefix ## xcommit ((s)->u.xcommit.lsn,(s)->u.xcommit.xid, __VA_ARGS__); break;\
  case LT_xprepare: funprefix ## xprepare ((s)->u.xprepare.lsn,(s)->u.xprepare.xid,(s)->u.xprepare.xa_xid, __VA_ARGS__); break;\
  case LT_xabort: funprefix ## xabort ((s)->u.xabort.lsn,(s)->u.xabort.xid, __VA_ARGS__); break;\
  case LT_fcreate: funprefix ## fcreate ((s)->u.fcreate.lsn,(s)->u.fcreate.xid,(s)->u.fcreate.filenum,(s)->u.fcreate.iname,(s)->u.fcreate.mode,(s)->u.fcreate.treeflags,(s)->u.fcreate.nodesize,(s)->u.fcreate.basementnodesize,(s)->u.fcreate.compression_method, __VA_ARGS__); break;\
  case LT_fopen: funprefix ## fopen ((s)->u.fopen.lsn,(s)->u.fopen.iname,(s)->u.fopen.filenum,(s)->u.fopen.treeflags, __VA_ARGS__); break;\
  case LT_fclose: funprefix ## fclose ((s)->u.fclose.lsn,(s)->u.fclose.iname,(s)->u.fclose.filenum, __VA_ARGS__); break;\
  case LT_fdelete: funprefix ## fdelete ((s)->u.fdelete.lsn,(s)->u.fdelete.xid,(s)->u.fdelete.filenum, __VA_ARGS__); break;\
  case LT_enq_insert: funprefix ## enq_insert ((s)->u.enq_insert.lsn,(s)->u.enq_insert.filenum,(s)->u.enq_insert.xid,(s)->u.enq_insert.key,(s)->u.enq_insert.value, __VA_ARGS__); break;\
  case LT_enq_insert_no_overwrite: funprefix ## enq_insert_no_overwrite ((s)->u.enq_insert_no_overwrite.lsn,(s)->u.enq_insert_no_overwrite.filenum,(s)->u.enq_insert_no_overwrite.xid,(s)->u.enq_insert_no_overwrite.key,(s)->u.enq_insert_no_overwrite.value, __VA_ARGS__); break;\
  case LT_enq_delete_any: funprefix ## enq_delete_any ((s)->u.enq_delete_any.lsn,(s)->u.enq_delete_any.filenum,(s)->u.enq_delete_any.xid,(s)->u.enq_delete_any.key, __VA_ARGS__); break;\
  case LT_enq_insert_multiple: funprefix ## enq_insert_multiple ((s)->u.enq_insert_multiple.lsn,(s)->u.enq_insert_multiple.src_filenum,(s)->u.enq_insert_multiple.dest_filenums,(s)->u.enq_insert_multiple.xid,(s)->u.enq_insert_multiple.src_key,(s)->u.enq_insert_multiple.src_val, __VA_ARGS__); break;\
  case LT_enq_delete_multiple: funprefix ## enq_delete_multiple ((s)->u.enq_delete_multiple.lsn,(s)->u.enq_delete_multiple.src_filenum,(s)->u.enq_delete_multiple.dest_filenums,(s)->u.enq_delete_multiple.xid,(s)->u.enq_delete_multiple.src_key,(s)->u.enq_delete_multiple.src_val, __VA_ARGS__); break;\
  case LT_comment: funprefix ## comment ((s)->u.comment.lsn,(s)->u.comment.timestamp,(s)->u.comment.comment, __VA_ARGS__); break;\
  case LT_enq_delete_multi: funprefix ## enq_delete_multi ((s)->u.enq_delete_multi.lsn,(s)->u.enq_delete_multi.filenum,(s)->u.enq_delete_multi.xid,(s)->u.enq_delete_multi.min_key,(s)->u.enq_delete_multi.max_key,(s)->u.enq_delete_multi.is_right_excl,(s)->u.enq_delete_multi.pm_status,(s)->u.enq_delete_multi.is_resetting_op, __VA_ARGS__); break;\
  case LT_enq_unbound_insert: funprefix ## enq_unbound_insert ((s)->u.enq_unbound_insert.lsn,(s)->u.enq_unbound_insert.filenum,(s)->u.enq_unbound_insert.xid,(s)->u.enq_unbound_insert.key, __VA_ARGS__); break;\
  case LT_sync_unbound_insert: funprefix ## sync_unbound_insert ((s)->u.sync_unbound_insert.lsn,(s)->u.sync_unbound_insert.msn_in_tree,(s)->u.sync_unbound_insert.lsn_of_enq,(s)->u.sync_unbound_insert.offset,(s)->u.sync_unbound_insert.size, __VA_ARGS__); break;\
  case LT_shutdown_up_to_19: funprefix ## shutdown_up_to_19 ((s)->u.shutdown_up_to_19.lsn,(s)->u.shutdown_up_to_19.timestamp, __VA_ARGS__); break;\
  case LT_shutdown: funprefix ## shutdown ((s)->u.shutdown.lsn,(s)->u.shutdown.timestamp,(s)->u.shutdown.last_xid, __VA_ARGS__); break;\
  case LT_load: funprefix ## load ((s)->u.load.lsn,(s)->u.load.xid,(s)->u.load.old_filenum,(s)->u.load.new_iname, __VA_ARGS__); break;\
  case LT_hot_index: funprefix ## hot_index ((s)->u.hot_index.lsn,(s)->u.hot_index.xid,(s)->u.hot_index.hot_index_filenums, __VA_ARGS__); break;\
  case LT_enq_update: funprefix ## enq_update ((s)->u.enq_update.lsn,(s)->u.enq_update.filenum,(s)->u.enq_update.xid,(s)->u.enq_update.key,(s)->u.enq_update.extra, __VA_ARGS__); break;\
  case LT_enq_updatebroadcast: funprefix ## enq_updatebroadcast ((s)->u.enq_updatebroadcast.lsn,(s)->u.enq_updatebroadcast.filenum,(s)->u.enq_updatebroadcast.xid,(s)->u.enq_updatebroadcast.extra,(s)->u.enq_updatebroadcast.is_resetting_op, __VA_ARGS__); break;\
  case LT_change_fdescriptor: funprefix ## change_fdescriptor ((s)->u.change_fdescriptor.lsn,(s)->u.change_fdescriptor.filenum,(s)->u.change_fdescriptor.xid,(s)->u.change_fdescriptor.old_descriptor,(s)->u.change_fdescriptor.new_descriptor,(s)->u.change_fdescriptor.update_cmp_descriptor, __VA_ARGS__); break;\
 }} while (0)
static const size_t toku_log_begin_checkpoint_overhead = (+4+1+8+sizeof(uint64_t)+sizeof(TXNID)+8);
void toku_log_begin_checkpoint (TOKULOGGER logger, LSN *lsnp, int do_fsync, uint64_t timestamp, TXNID last_xid);
static const size_t toku_log_end_checkpoint_overhead = (+4+1+8+sizeof(LSN)+sizeof(uint64_t)+sizeof(uint32_t)+sizeof(uint32_t)+8);
void toku_log_end_checkpoint (TOKULOGGER logger, LSN *lsnp, int do_fsync, LSN lsn_begin_checkpoint, uint64_t timestamp, uint32_t num_fassociate_entries, uint32_t num_xstillopen_entries);
static const size_t toku_log_fassociate_overhead = (+4+1+8+sizeof(FILENUM)+sizeof(uint32_t)+sizeof(BYTESTRING)+sizeof(uint8_t)+8);
void toku_log_fassociate (TOKULOGGER logger, LSN *lsnp, int do_fsync, FILENUM filenum, uint32_t treeflags, BYTESTRING iname, uint8_t unlink_on_close);
static const size_t toku_log_xstillopen_overhead = (+4+1+8+sizeof(TXNID_PAIR)+sizeof(TXNID_PAIR)+sizeof(uint64_t)+sizeof(FILENUMS)+sizeof(uint8_t)+sizeof(uint64_t)+sizeof(uint64_t)+sizeof(BLOCKNUM)+sizeof(BLOCKNUM)+sizeof(BLOCKNUM)+8);
void toku_log_xstillopen (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, TXNID_PAIR xid, TXNID_PAIR parentxid, uint64_t rollentry_raw_count, FILENUMS open_filenums, uint8_t force_fsync_on_commit, uint64_t num_rollback_nodes, uint64_t num_rollentries, BLOCKNUM spilled_rollback_head, BLOCKNUM spilled_rollback_tail, BLOCKNUM current_rollback);
static const size_t toku_log_xstillopenprepared_overhead = (+4+1+8+sizeof(TXNID_PAIR)+sizeof(XIDP)+sizeof(uint64_t)+sizeof(FILENUMS)+sizeof(uint8_t)+sizeof(uint64_t)+sizeof(uint64_t)+sizeof(BLOCKNUM)+sizeof(BLOCKNUM)+sizeof(BLOCKNUM)+8);
void toku_log_xstillopenprepared (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, TXNID_PAIR xid, XIDP xa_xid, uint64_t rollentry_raw_count, FILENUMS open_filenums, uint8_t force_fsync_on_commit, uint64_t num_rollback_nodes, uint64_t num_rollentries, BLOCKNUM spilled_rollback_head, BLOCKNUM spilled_rollback_tail, BLOCKNUM current_rollback);
static const size_t toku_log_xbegin_overhead = (+4+1+8+sizeof(TXNID_PAIR)+sizeof(TXNID_PAIR)+8);
void toku_log_xbegin (TOKULOGGER logger, LSN *lsnp, int do_fsync, TXNID_PAIR xid, TXNID_PAIR parentxid);
static const size_t toku_log_xcommit_overhead = (+4+1+8+sizeof(TXNID_PAIR)+8);
void toku_log_xcommit (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, TXNID_PAIR xid);
static const size_t toku_log_xprepare_overhead = (+4+1+8+sizeof(TXNID_PAIR)+sizeof(XIDP)+8);
void toku_log_xprepare (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, TXNID_PAIR xid, XIDP xa_xid);
static const size_t toku_log_xabort_overhead = (+4+1+8+sizeof(TXNID_PAIR)+8);
void toku_log_xabort (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, TXNID_PAIR xid);
static const size_t toku_log_fcreate_overhead = (+4+1+8+sizeof(TXNID_PAIR)+sizeof(FILENUM)+sizeof(BYTESTRING)+sizeof(uint32_t)+sizeof(uint32_t)+sizeof(uint32_t)+sizeof(uint32_t)+sizeof(uint32_t)+8);
void toku_log_fcreate (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, TXNID_PAIR xid, FILENUM filenum, BYTESTRING iname, uint32_t mode, uint32_t treeflags, uint32_t nodesize, uint32_t basementnodesize, uint32_t compression_method);
static const size_t toku_log_fopen_overhead = (+4+1+8+sizeof(BYTESTRING)+sizeof(FILENUM)+sizeof(uint32_t)+8);
void toku_log_fopen (TOKULOGGER logger, LSN *lsnp, int do_fsync, BYTESTRING iname, FILENUM filenum, uint32_t treeflags);
static const size_t toku_log_fclose_overhead = (+4+1+8+sizeof(BYTESTRING)+sizeof(FILENUM)+8);
void toku_log_fclose (TOKULOGGER logger, LSN *lsnp, int do_fsync, BYTESTRING iname, FILENUM filenum);
static const size_t toku_log_fdelete_overhead = (+4+1+8+sizeof(TXNID_PAIR)+sizeof(FILENUM)+8);
void toku_log_fdelete (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, TXNID_PAIR xid, FILENUM filenum);
static const size_t toku_log_enq_insert_overhead = (+4+1+8+sizeof(FILENUM)+sizeof(TXNID_PAIR)+sizeof(BYTESTRING)+sizeof(BYTESTRING)+8);
void toku_log_enq_insert (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM filenum, TXNID_PAIR xid, BYTESTRING key, BYTESTRING value);
static const size_t toku_log_enq_insert_no_overwrite_overhead = (+4+1+8+sizeof(FILENUM)+sizeof(TXNID_PAIR)+sizeof(BYTESTRING)+sizeof(BYTESTRING)+8);
void toku_log_enq_insert_no_overwrite (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM filenum, TXNID_PAIR xid, BYTESTRING key, BYTESTRING value);
static const size_t toku_log_enq_delete_any_overhead = (+4+1+8+sizeof(FILENUM)+sizeof(TXNID_PAIR)+sizeof(BYTESTRING)+8);
void toku_log_enq_delete_any (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM filenum, TXNID_PAIR xid, BYTESTRING key);
static const size_t toku_log_enq_insert_multiple_overhead = (+4+1+8+sizeof(FILENUM)+sizeof(FILENUMS)+sizeof(TXNID_PAIR)+sizeof(BYTESTRING)+sizeof(BYTESTRING)+8);
void toku_log_enq_insert_multiple (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM src_filenum, FILENUMS dest_filenums, TXNID_PAIR xid, BYTESTRING src_key, BYTESTRING src_val);
static const size_t toku_log_enq_delete_multiple_overhead = (+4+1+8+sizeof(FILENUM)+sizeof(FILENUMS)+sizeof(TXNID_PAIR)+sizeof(BYTESTRING)+sizeof(BYTESTRING)+8);
void toku_log_enq_delete_multiple (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM src_filenum, FILENUMS dest_filenums, TXNID_PAIR xid, BYTESTRING src_key, BYTESTRING src_val);
static const size_t toku_log_comment_overhead = (+4+1+8+sizeof(uint64_t)+sizeof(BYTESTRING)+8);
void toku_log_comment (TOKULOGGER logger, LSN *lsnp, int do_fsync, uint64_t timestamp, BYTESTRING comment);
static const size_t toku_log_enq_delete_multi_overhead = (+4+1+8+sizeof(FILENUM)+sizeof(TXNID_PAIR)+sizeof(BYTESTRING)+sizeof(BYTESTRING)+sizeof(bool)+sizeof(uint32_t)+sizeof(bool)+8);
void toku_log_enq_delete_multi (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM filenum, TXNID_PAIR xid, BYTESTRING min_key, BYTESTRING max_key, bool is_right_excl, uint32_t pm_status, bool is_resetting_op);
static const size_t toku_log_enq_unbound_insert_overhead = (+4+1+8+sizeof(FILENUM)+sizeof(TXNID_PAIR)+sizeof(BYTESTRING)+8);
void toku_log_enq_unbound_insert (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM filenum, TXNID_PAIR xid, BYTESTRING key);
static const size_t toku_log_sync_unbound_insert_overhead = (+4+1+8+sizeof(MSN)+sizeof(LSN)+sizeof(DISKOFF)+sizeof(DISKOFF)+8);
void toku_log_sync_unbound_insert (TOKULOGGER logger, LSN *lsnp, int do_fsync, MSN msn_in_tree, LSN lsn_of_enq, DISKOFF offset, DISKOFF size);
static const size_t toku_log_shutdown_up_to_19_overhead = (+4+1+8+sizeof(uint64_t)+8);
void toku_log_shutdown_up_to_19 (TOKULOGGER logger, LSN *lsnp, int do_fsync, uint64_t timestamp);
static const size_t toku_log_shutdown_overhead = (+4+1+8+sizeof(uint64_t)+sizeof(TXNID)+8);
void toku_log_shutdown (TOKULOGGER logger, LSN *lsnp, int do_fsync, uint64_t timestamp, TXNID last_xid);
static const size_t toku_log_load_overhead = (+4+1+8+sizeof(TXNID_PAIR)+sizeof(FILENUM)+sizeof(BYTESTRING)+8);
void toku_log_load (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, TXNID_PAIR xid, FILENUM old_filenum, BYTESTRING new_iname);
static const size_t toku_log_hot_index_overhead = (+4+1+8+sizeof(TXNID_PAIR)+sizeof(FILENUMS)+8);
void toku_log_hot_index (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, TXNID_PAIR xid, FILENUMS hot_index_filenums);
static const size_t toku_log_enq_update_overhead = (+4+1+8+sizeof(FILENUM)+sizeof(TXNID_PAIR)+sizeof(BYTESTRING)+sizeof(BYTESTRING)+8);
void toku_log_enq_update (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM filenum, TXNID_PAIR xid, BYTESTRING key, BYTESTRING extra);
static const size_t toku_log_enq_updatebroadcast_overhead = (+4+1+8+sizeof(FILENUM)+sizeof(TXNID_PAIR)+sizeof(BYTESTRING)+sizeof(bool)+8);
void toku_log_enq_updatebroadcast (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM filenum, TXNID_PAIR xid, BYTESTRING extra, bool is_resetting_op);
static const size_t toku_log_change_fdescriptor_overhead = (+4+1+8+sizeof(FILENUM)+sizeof(TXNID_PAIR)+sizeof(BYTESTRING)+sizeof(BYTESTRING)+sizeof(bool)+8);
void toku_log_change_fdescriptor (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM filenum, TXNID_PAIR xid, BYTESTRING old_descriptor, BYTESTRING new_descriptor, bool update_cmp_descriptor);
int toku_log_fread (FILE *infile, struct log_entry *le);
// Return 0 if there is something to read, -1 if nothing to read, >0 on error
int toku_log_fread_backward (FILE *infile, struct log_entry *le);
void toku_log_free_log_entry_resources (struct log_entry *le);
void toku_logger_save_rollback_fdelete (TOKUTXN txn, FILENUM filenum);
void toku_logger_save_rollback_fcreate (TOKUTXN txn, FILENUM filenum, BYTESTRING *iname_ptr);
void toku_logger_save_rollback_cmdinsert (TOKUTXN txn, FILENUM filenum, BYTESTRING *key_ptr);
void toku_logger_save_rollback_cmdseqinsert (TOKUTXN txn, FILENUM filenum, BYTESTRING *key_ptr);
void toku_logger_save_rollback_cmddelete (TOKUTXN txn, FILENUM filenum, BYTESTRING *key_ptr);
void toku_logger_save_rollback_cmddeletemulti (TOKUTXN txn, FILENUM filenum, BYTESTRING *min_key_ptr, BYTESTRING *max_key_ptr, bool is_right_excl, uint32_t pm_status, bool is_resetting_op);
void toku_logger_save_rollback_rollinclude (TOKUTXN txn, TXNID_PAIR xid, uint64_t num_nodes, BLOCKNUM spilled_head, BLOCKNUM spilled_tail);
void toku_logger_save_rollback_load (TOKUTXN txn, FILENUM old_filenum, BYTESTRING *new_iname_ptr);
void toku_logger_save_rollback_hot_index (TOKUTXN txn, FILENUMS *hot_index_filenums_ptr);
void toku_logger_save_rollback_dictionary_redirect (TOKUTXN txn, FILENUM old_filenum, FILENUM new_filenum);
void toku_logger_save_rollback_cmdupdate (TOKUTXN txn, FILENUM filenum, BYTESTRING *key_ptr);
void toku_logger_save_rollback_cmdupdatebroadcast (TOKUTXN txn, FILENUM filenum, bool is_resetting_op);
void toku_logger_save_rollback_change_fdescriptor (TOKUTXN txn, FILENUM filenum, BYTESTRING *old_descriptor_ptr);
void toku_logger_rollback_wbuf_nocrc_write_fdelete (struct wbuf *wbuf, FILENUM filenum);
void toku_logger_rollback_wbuf_nocrc_write_fcreate (struct wbuf *wbuf, FILENUM filenum, BYTESTRING iname);
void toku_logger_rollback_wbuf_nocrc_write_cmdinsert (struct wbuf *wbuf, FILENUM filenum, BYTESTRING key);
void toku_logger_rollback_wbuf_nocrc_write_cmdseqinsert (struct wbuf *wbuf, FILENUM filenum, BYTESTRING key);
void toku_logger_rollback_wbuf_nocrc_write_cmddelete (struct wbuf *wbuf, FILENUM filenum, BYTESTRING key);
void toku_logger_rollback_wbuf_nocrc_write_cmddeletemulti (struct wbuf *wbuf, FILENUM filenum, BYTESTRING min_key, BYTESTRING max_key, bool is_right_excl, uint32_t pm_status, bool is_resetting_op);
void toku_logger_rollback_wbuf_nocrc_write_rollinclude (struct wbuf *wbuf, TXNID_PAIR xid, uint64_t num_nodes, BLOCKNUM spilled_head, BLOCKNUM spilled_tail);
void toku_logger_rollback_wbuf_nocrc_write_load (struct wbuf *wbuf, FILENUM old_filenum, BYTESTRING new_iname);
void toku_logger_rollback_wbuf_nocrc_write_hot_index (struct wbuf *wbuf, FILENUMS hot_index_filenums);
void toku_logger_rollback_wbuf_nocrc_write_dictionary_redirect (struct wbuf *wbuf, FILENUM old_filenum, FILENUM new_filenum);
void toku_logger_rollback_wbuf_nocrc_write_cmdupdate (struct wbuf *wbuf, FILENUM filenum, BYTESTRING key);
void toku_logger_rollback_wbuf_nocrc_write_cmdupdatebroadcast (struct wbuf *wbuf, FILENUM filenum, bool is_resetting_op);
void toku_logger_rollback_wbuf_nocrc_write_change_fdescriptor (struct wbuf *wbuf, FILENUM filenum, BYTESTRING old_descriptor);
void toku_logger_rollback_wbuf_nocrc_write (struct wbuf *wbuf, struct roll_entry *r);
uint32_t toku_logger_rollback_fsize_fdelete (FILENUM filenum);
uint32_t toku_logger_rollback_fsize_fcreate (FILENUM filenum, BYTESTRING iname);
uint32_t toku_logger_rollback_fsize_cmdinsert (FILENUM filenum, BYTESTRING key);
uint32_t toku_logger_rollback_fsize_cmdseqinsert (FILENUM filenum, BYTESTRING key);
uint32_t toku_logger_rollback_fsize_cmddelete (FILENUM filenum, BYTESTRING key);
uint32_t toku_logger_rollback_fsize_cmddeletemulti (FILENUM filenum, BYTESTRING min_key, BYTESTRING max_key, bool is_right_excl, uint32_t pm_status, bool is_resetting_op);
uint32_t toku_logger_rollback_fsize_rollinclude (TXNID_PAIR xid, uint64_t num_nodes, BLOCKNUM spilled_head, BLOCKNUM spilled_tail);
uint32_t toku_logger_rollback_fsize_load (FILENUM old_filenum, BYTESTRING new_iname);
uint32_t toku_logger_rollback_fsize_hot_index (FILENUMS hot_index_filenums);
uint32_t toku_logger_rollback_fsize_dictionary_redirect (FILENUM old_filenum, FILENUM new_filenum);
uint32_t toku_logger_rollback_fsize_cmdupdate (FILENUM filenum, BYTESTRING key);
uint32_t toku_logger_rollback_fsize_cmdupdatebroadcast (FILENUM filenum, bool is_resetting_op);
uint32_t toku_logger_rollback_fsize_change_fdescriptor (FILENUM filenum, BYTESTRING old_descriptor);
uint32_t toku_logger_rollback_fsize(struct roll_entry *item);
int toku_parse_rollback(unsigned char *buf, uint32_t n_bytes, struct roll_entry **itemp, MEMARENA ma);
LSN toku_log_entry_get_lsn(struct log_entry *);
int toku_logprint_one_record(FILE *outf, FILE *f);
#endif

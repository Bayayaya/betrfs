/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*- */
// vim: ft=cpp:expandtab:ts=8:sw=4:softtabstop=4:
/* Do not edit this file.  This code generated by logformat.c.  Copyright (c) 2007-2013 Tokutek Inc.    */
#ident "Copyright (c) 2007-2013 Tokutek Inc.  All rights reserved."
#include <stdint.h>
#include <sys/time.h>
#include <ft/fttypes.h>
#include <ft/log-internal.h>
static uint64_t toku_get_timestamp(void) {
  struct timeval tv; int r = gettimeofday(&tv, NULL);
  assert(r==0);
  return tv.tv_sec * 1000000ULL + tv.tv_usec;
}
void toku_log_begin_checkpoint (TOKULOGGER logger, LSN *lsnp, int do_fsync, uint64_t timestamp, TXNID last_xid) {
  if (logger == NULL) {
     return;
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_uint64_t(timestamp)
                              +toku_logsizeof_TXNID(last_xid)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'x');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  if (timestamp == 0) timestamp = toku_get_timestamp();
  wbuf_nocrc_uint64_t(&wbuf, timestamp);
  wbuf_nocrc_TXNID(&wbuf, last_xid);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_end_checkpoint (TOKULOGGER logger, LSN *lsnp, int do_fsync, LSN lsn_begin_checkpoint, uint64_t timestamp, uint32_t num_fassociate_entries, uint32_t num_xstillopen_entries) {
  if (logger == NULL) {
     return;
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_LSN(lsn_begin_checkpoint)
                              +toku_logsizeof_uint64_t(timestamp)
                              +toku_logsizeof_uint32_t(num_fassociate_entries)
                              +toku_logsizeof_uint32_t(num_xstillopen_entries)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'X');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_LSN(&wbuf, lsn_begin_checkpoint);
  if (timestamp == 0) timestamp = toku_get_timestamp();
  wbuf_nocrc_uint64_t(&wbuf, timestamp);
  wbuf_nocrc_uint32_t(&wbuf, num_fassociate_entries);
  wbuf_nocrc_uint32_t(&wbuf, num_xstillopen_entries);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_fassociate (TOKULOGGER logger, LSN *lsnp, int do_fsync, FILENUM filenum, uint32_t treeflags, BYTESTRING iname, uint8_t unlink_on_close) {
  if (logger == NULL) {
     return;
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_FILENUM(filenum)
                              +toku_logsizeof_uint32_t(treeflags)
                              +toku_logsizeof_BYTESTRING(iname)
                              +toku_logsizeof_uint8_t(unlink_on_close)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'f');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_FILENUM(&wbuf, filenum);
  wbuf_nocrc_uint32_t(&wbuf, treeflags);
  wbuf_nocrc_BYTESTRING(&wbuf, iname);
  wbuf_nocrc_uint8_t(&wbuf, unlink_on_close);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_xstillopen (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, TXNID_PAIR xid, TXNID_PAIR parentxid, uint64_t rollentry_raw_count, FILENUMS open_filenums, uint8_t force_fsync_on_commit, uint64_t num_rollback_nodes, uint64_t num_rollentries, BLOCKNUM spilled_rollback_head, BLOCKNUM spilled_rollback_tail, BLOCKNUM current_rollback) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  invariant(!txn || txn->begin_was_logged);
  invariant(!txn || !txn_declared_read_only(txn));
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +toku_logsizeof_TXNID_PAIR(parentxid)
                              +toku_logsizeof_uint64_t(rollentry_raw_count)
                              +toku_logsizeof_FILENUMS(open_filenums)
                              +toku_logsizeof_uint8_t(force_fsync_on_commit)
                              +toku_logsizeof_uint64_t(num_rollback_nodes)
                              +toku_logsizeof_uint64_t(num_rollentries)
                              +toku_logsizeof_BLOCKNUM(spilled_rollback_head)
                              +toku_logsizeof_BLOCKNUM(spilled_rollback_tail)
                              +toku_logsizeof_BLOCKNUM(current_rollback)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 's');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_TXNID_PAIR(&wbuf, parentxid);
  wbuf_nocrc_uint64_t(&wbuf, rollentry_raw_count);
  wbuf_nocrc_FILENUMS(&wbuf, open_filenums);
  wbuf_nocrc_uint8_t(&wbuf, force_fsync_on_commit);
  wbuf_nocrc_uint64_t(&wbuf, num_rollback_nodes);
  wbuf_nocrc_uint64_t(&wbuf, num_rollentries);
  wbuf_nocrc_BLOCKNUM(&wbuf, spilled_rollback_head);
  wbuf_nocrc_BLOCKNUM(&wbuf, spilled_rollback_tail);
  wbuf_nocrc_BLOCKNUM(&wbuf, current_rollback);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_xstillopenprepared (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, TXNID_PAIR xid, XIDP xa_xid, uint64_t rollentry_raw_count, FILENUMS open_filenums, uint8_t force_fsync_on_commit, uint64_t num_rollback_nodes, uint64_t num_rollentries, BLOCKNUM spilled_rollback_head, BLOCKNUM spilled_rollback_tail, BLOCKNUM current_rollback) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  invariant(!txn || txn->begin_was_logged);
  invariant(!txn || !txn_declared_read_only(txn));
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +toku_logsizeof_XIDP(xa_xid)
                              +toku_logsizeof_uint64_t(rollentry_raw_count)
                              +toku_logsizeof_FILENUMS(open_filenums)
                              +toku_logsizeof_uint8_t(force_fsync_on_commit)
                              +toku_logsizeof_uint64_t(num_rollback_nodes)
                              +toku_logsizeof_uint64_t(num_rollentries)
                              +toku_logsizeof_BLOCKNUM(spilled_rollback_head)
                              +toku_logsizeof_BLOCKNUM(spilled_rollback_tail)
                              +toku_logsizeof_BLOCKNUM(current_rollback)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'p');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_XIDP(&wbuf, xa_xid);
  wbuf_nocrc_uint64_t(&wbuf, rollentry_raw_count);
  wbuf_nocrc_FILENUMS(&wbuf, open_filenums);
  wbuf_nocrc_uint8_t(&wbuf, force_fsync_on_commit);
  wbuf_nocrc_uint64_t(&wbuf, num_rollback_nodes);
  wbuf_nocrc_uint64_t(&wbuf, num_rollentries);
  wbuf_nocrc_BLOCKNUM(&wbuf, spilled_rollback_head);
  wbuf_nocrc_BLOCKNUM(&wbuf, spilled_rollback_tail);
  wbuf_nocrc_BLOCKNUM(&wbuf, current_rollback);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_xbegin (TOKULOGGER logger, LSN *lsnp, int do_fsync, TXNID_PAIR xid, TXNID_PAIR parentxid) {
  if (logger == NULL) {
     return;
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +toku_logsizeof_TXNID_PAIR(parentxid)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'b');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_TXNID_PAIR(&wbuf, parentxid);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_xcommit (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, TXNID_PAIR xid) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  invariant(!txn || txn->begin_was_logged);
  invariant(!txn || !txn_declared_read_only(txn));
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'C');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_xprepare (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, TXNID_PAIR xid, XIDP xa_xid) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  invariant(!txn || txn->begin_was_logged);
  invariant(!txn || !txn_declared_read_only(txn));
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +toku_logsizeof_XIDP(xa_xid)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'P');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_XIDP(&wbuf, xa_xid);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_xabort (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, TXNID_PAIR xid) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  invariant(!txn || txn->begin_was_logged);
  invariant(!txn || !txn_declared_read_only(txn));
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'q');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_fcreate (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, TXNID_PAIR xid, FILENUM filenum, BYTESTRING iname, uint32_t mode, uint32_t treeflags, uint32_t nodesize, uint32_t basementnodesize, uint32_t compression_method) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  //never null when not checkpoint.
  if (txn && !txn->begin_was_logged) {
    invariant(!txn_declared_read_only(txn));
    toku_maybe_log_begin_txn_for_write_operation(txn);
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +toku_logsizeof_FILENUM(filenum)
                              +toku_logsizeof_BYTESTRING(iname)
                              +toku_logsizeof_uint32_t(mode)
                              +toku_logsizeof_uint32_t(treeflags)
                              +toku_logsizeof_uint32_t(nodesize)
                              +toku_logsizeof_uint32_t(basementnodesize)
                              +toku_logsizeof_uint32_t(compression_method)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'F');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_FILENUM(&wbuf, filenum);
  wbuf_nocrc_BYTESTRING(&wbuf, iname);
  wbuf_nocrc_uint32_t(&wbuf, mode);
  wbuf_nocrc_uint32_t(&wbuf, treeflags);
  wbuf_nocrc_uint32_t(&wbuf, nodesize);
  wbuf_nocrc_uint32_t(&wbuf, basementnodesize);
  wbuf_nocrc_uint32_t(&wbuf, compression_method);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_fopen (TOKULOGGER logger, LSN *lsnp, int do_fsync, BYTESTRING iname, FILENUM filenum, uint32_t treeflags) {
  if (logger == NULL) {
     return;
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_BYTESTRING(iname)
                              +toku_logsizeof_FILENUM(filenum)
                              +toku_logsizeof_uint32_t(treeflags)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'O');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_BYTESTRING(&wbuf, iname);
  wbuf_nocrc_FILENUM(&wbuf, filenum);
  wbuf_nocrc_uint32_t(&wbuf, treeflags);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_fclose (TOKULOGGER logger, LSN *lsnp, int do_fsync, BYTESTRING iname, FILENUM filenum) {
  if (logger == NULL) {
     return;
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_BYTESTRING(iname)
                              +toku_logsizeof_FILENUM(filenum)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'e');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_BYTESTRING(&wbuf, iname);
  wbuf_nocrc_FILENUM(&wbuf, filenum);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_fdelete (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, TXNID_PAIR xid, FILENUM filenum) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  //never null when not checkpoint.
  if (txn && !txn->begin_was_logged) {
    invariant(!txn_declared_read_only(txn));
    toku_maybe_log_begin_txn_for_write_operation(txn);
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +toku_logsizeof_FILENUM(filenum)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'U');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_FILENUM(&wbuf, filenum);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_enq_insert (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM filenum, TXNID_PAIR xid, BYTESTRING key, BYTESTRING value) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  //never null when not checkpoint.
  if (txn && !txn->begin_was_logged) {
    invariant(!txn_declared_read_only(txn));
    toku_maybe_log_begin_txn_for_write_operation(txn);
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_FILENUM(filenum)
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +toku_logsizeof_BYTESTRING(key)
                              +toku_logsizeof_BYTESTRING(value)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'I');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_FILENUM(&wbuf, filenum);
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_BYTESTRING(&wbuf, key);
  wbuf_nocrc_BYTESTRING(&wbuf, value);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_enq_insert_no_overwrite (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM filenum, TXNID_PAIR xid, BYTESTRING key, BYTESTRING value) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  //never null when not checkpoint.
  if (txn && !txn->begin_was_logged) {
    invariant(!txn_declared_read_only(txn));
    toku_maybe_log_begin_txn_for_write_operation(txn);
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_FILENUM(filenum)
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +toku_logsizeof_BYTESTRING(key)
                              +toku_logsizeof_BYTESTRING(value)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'i');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_FILENUM(&wbuf, filenum);
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_BYTESTRING(&wbuf, key);
  wbuf_nocrc_BYTESTRING(&wbuf, value);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_enq_delete_any (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM filenum, TXNID_PAIR xid, BYTESTRING key) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  //never null when not checkpoint.
  if (txn && !txn->begin_was_logged) {
    invariant(!txn_declared_read_only(txn));
    toku_maybe_log_begin_txn_for_write_operation(txn);
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_FILENUM(filenum)
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +toku_logsizeof_BYTESTRING(key)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'E');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_FILENUM(&wbuf, filenum);
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_BYTESTRING(&wbuf, key);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_enq_insert_multiple (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM src_filenum, FILENUMS dest_filenums, TXNID_PAIR xid, BYTESTRING src_key, BYTESTRING src_val) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  //never null when not checkpoint.
  if (txn && !txn->begin_was_logged) {
    invariant(!txn_declared_read_only(txn));
    toku_maybe_log_begin_txn_for_write_operation(txn);
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_FILENUM(src_filenum)
                              +toku_logsizeof_FILENUMS(dest_filenums)
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +toku_logsizeof_BYTESTRING(src_key)
                              +toku_logsizeof_BYTESTRING(src_val)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'm');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_FILENUM(&wbuf, src_filenum);
  wbuf_nocrc_FILENUMS(&wbuf, dest_filenums);
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_BYTESTRING(&wbuf, src_key);
  wbuf_nocrc_BYTESTRING(&wbuf, src_val);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_enq_delete_multiple (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM src_filenum, FILENUMS dest_filenums, TXNID_PAIR xid, BYTESTRING src_key, BYTESTRING src_val) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  //never null when not checkpoint.
  if (txn && !txn->begin_was_logged) {
    invariant(!txn_declared_read_only(txn));
    toku_maybe_log_begin_txn_for_write_operation(txn);
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_FILENUM(src_filenum)
                              +toku_logsizeof_FILENUMS(dest_filenums)
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +toku_logsizeof_BYTESTRING(src_key)
                              +toku_logsizeof_BYTESTRING(src_val)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'M');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_FILENUM(&wbuf, src_filenum);
  wbuf_nocrc_FILENUMS(&wbuf, dest_filenums);
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_BYTESTRING(&wbuf, src_key);
  wbuf_nocrc_BYTESTRING(&wbuf, src_val);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_comment (TOKULOGGER logger, LSN *lsnp, int do_fsync, uint64_t timestamp, BYTESTRING comment) {
  if (logger == NULL) {
     return;
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_uint64_t(timestamp)
                              +toku_logsizeof_BYTESTRING(comment)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'T');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  if (timestamp == 0) timestamp = toku_get_timestamp();
  wbuf_nocrc_uint64_t(&wbuf, timestamp);
  wbuf_nocrc_BYTESTRING(&wbuf, comment);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_enq_delete_multi (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM filenum, TXNID_PAIR xid, BYTESTRING min_key, BYTESTRING max_key, bool is_right_excl, uint32_t pm_status, bool is_resetting_op) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  //never null when not checkpoint.
  if (txn && !txn->begin_was_logged) {
    invariant(!txn_declared_read_only(txn));
    toku_maybe_log_begin_txn_for_write_operation(txn);
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_FILENUM(filenum)
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +toku_logsizeof_BYTESTRING(min_key)
                              +toku_logsizeof_BYTESTRING(max_key)
                              +toku_logsizeof_bool(is_right_excl)
                              +toku_logsizeof_uint32_t(pm_status)
                              +toku_logsizeof_bool(is_resetting_op)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'Z');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_FILENUM(&wbuf, filenum);
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_BYTESTRING(&wbuf, min_key);
  wbuf_nocrc_BYTESTRING(&wbuf, max_key);
  wbuf_nocrc_bool(&wbuf, is_right_excl);
  wbuf_nocrc_uint32_t(&wbuf, pm_status);
  wbuf_nocrc_bool(&wbuf, is_resetting_op);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_enq_unbound_insert (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM filenum, TXNID_PAIR xid, BYTESTRING key) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  //never null when not checkpoint.
  if (txn && !txn->begin_was_logged) {
    invariant(!txn_declared_read_only(txn));
    toku_maybe_log_begin_txn_for_write_operation(txn);
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_FILENUM(filenum)
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +toku_logsizeof_BYTESTRING(key)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'G');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_FILENUM(&wbuf, filenum);
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_BYTESTRING(&wbuf, key);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_sync_unbound_insert (TOKULOGGER logger, LSN *lsnp, int do_fsync, MSN msn_in_tree, LSN lsn_of_enq, DISKOFF offset, DISKOFF size) {
  if (logger == NULL) {
     return;
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_MSN(msn_in_tree)
                              +toku_logsizeof_LSN(lsn_of_enq)
                              +toku_logsizeof_DISKOFF(offset)
                              +toku_logsizeof_DISKOFF(size)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'S');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_MSN(&wbuf, msn_in_tree);
  wbuf_nocrc_LSN(&wbuf, lsn_of_enq);
  wbuf_nocrc_DISKOFF(&wbuf, offset);
  wbuf_nocrc_DISKOFF(&wbuf, size);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_shutdown_up_to_19 (TOKULOGGER logger, LSN *lsnp, int do_fsync, uint64_t timestamp) {
  if (logger == NULL) {
     return;
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_uint64_t(timestamp)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'Q');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  if (timestamp == 0) timestamp = toku_get_timestamp();
  wbuf_nocrc_uint64_t(&wbuf, timestamp);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_shutdown (TOKULOGGER logger, LSN *lsnp, int do_fsync, uint64_t timestamp, TXNID last_xid) {
  if (logger == NULL) {
     return;
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_uint64_t(timestamp)
                              +toku_logsizeof_TXNID(last_xid)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, '0');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  if (timestamp == 0) timestamp = toku_get_timestamp();
  wbuf_nocrc_uint64_t(&wbuf, timestamp);
  wbuf_nocrc_TXNID(&wbuf, last_xid);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_load (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, TXNID_PAIR xid, FILENUM old_filenum, BYTESTRING new_iname) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  //never null when not checkpoint.
  if (txn && !txn->begin_was_logged) {
    invariant(!txn_declared_read_only(txn));
    toku_maybe_log_begin_txn_for_write_operation(txn);
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +toku_logsizeof_FILENUM(old_filenum)
                              +toku_logsizeof_BYTESTRING(new_iname)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'l');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_FILENUM(&wbuf, old_filenum);
  wbuf_nocrc_BYTESTRING(&wbuf, new_iname);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_hot_index (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, TXNID_PAIR xid, FILENUMS hot_index_filenums) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  //never null when not checkpoint.
  if (txn && !txn->begin_was_logged) {
    invariant(!txn_declared_read_only(txn));
    toku_maybe_log_begin_txn_for_write_operation(txn);
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +toku_logsizeof_FILENUMS(hot_index_filenums)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'h');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_FILENUMS(&wbuf, hot_index_filenums);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_enq_update (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM filenum, TXNID_PAIR xid, BYTESTRING key, BYTESTRING extra) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  //never null when not checkpoint.
  if (txn && !txn->begin_was_logged) {
    invariant(!txn_declared_read_only(txn));
    toku_maybe_log_begin_txn_for_write_operation(txn);
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_FILENUM(filenum)
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +toku_logsizeof_BYTESTRING(key)
                              +toku_logsizeof_BYTESTRING(extra)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'u');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_FILENUM(&wbuf, filenum);
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_BYTESTRING(&wbuf, key);
  wbuf_nocrc_BYTESTRING(&wbuf, extra);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_enq_updatebroadcast (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM filenum, TXNID_PAIR xid, BYTESTRING extra, bool is_resetting_op) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  //never null when not checkpoint.
  if (txn && !txn->begin_was_logged) {
    invariant(!txn_declared_read_only(txn));
    toku_maybe_log_begin_txn_for_write_operation(txn);
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_FILENUM(filenum)
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +toku_logsizeof_BYTESTRING(extra)
                              +toku_logsizeof_bool(is_resetting_op)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'B');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_FILENUM(&wbuf, filenum);
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_BYTESTRING(&wbuf, extra);
  wbuf_nocrc_bool(&wbuf, is_resetting_op);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

void toku_log_change_fdescriptor (TOKULOGGER logger, LSN *lsnp, int do_fsync, TOKUTXN txn, FILENUM filenum, TXNID_PAIR xid, BYTESTRING old_descriptor, BYTESTRING new_descriptor, bool update_cmp_descriptor) {
  if (logger == NULL) {
     return;
  }
  //txn can be NULL during tests
  //never null when not checkpoint.
  if (txn && !txn->begin_was_logged) {
    invariant(!txn_declared_read_only(txn));
    toku_maybe_log_begin_txn_for_write_operation(txn);
  }
  if (!logger->write_log_files) {
    ml_lock(&logger->input_lock);
    logger->lsn.lsn++;
    if (lsnp) *lsnp=logger->lsn;
    ml_unlock(&logger->input_lock);
    return;
  }
  const unsigned int buflen= (+4 // len at the beginning
                              +1 // log command
                              +8 // lsn
                              +toku_logsizeof_FILENUM(filenum)
                              +toku_logsizeof_TXNID_PAIR(xid)
                              +toku_logsizeof_BYTESTRING(old_descriptor)
                              +toku_logsizeof_BYTESTRING(new_descriptor)
                              +toku_logsizeof_bool(update_cmp_descriptor)
                              +8 // crc + len
                     );
  struct wbuf wbuf;
  ml_lock(&logger->input_lock);
  toku_logger_make_space_in_inbuf(logger, buflen);
  wbuf_nocrc_init(&wbuf, logger->inbuf.buf+logger->inbuf.n_in_buf, buflen);
  wbuf_nocrc_int(&wbuf, buflen);
  wbuf_nocrc_char(&wbuf, 'D');
  logger->lsn.lsn++;
  logger->inbuf.max_lsn_in_buf = logger->lsn;
  wbuf_nocrc_LSN(&wbuf, logger->lsn);
  if (lsnp) *lsnp=logger->lsn;
  wbuf_nocrc_FILENUM(&wbuf, filenum);
  wbuf_nocrc_TXNID_PAIR(&wbuf, xid);
  wbuf_nocrc_BYTESTRING(&wbuf, old_descriptor);
  wbuf_nocrc_BYTESTRING(&wbuf, new_descriptor);
  wbuf_nocrc_bool(&wbuf, update_cmp_descriptor);
  wbuf_nocrc_int(&wbuf, x1764_memory(wbuf.buf, wbuf.ndone));
  wbuf_nocrc_int(&wbuf, buflen);
  assert(wbuf.ndone==buflen);
  logger->inbuf.n_in_buf += buflen;
  toku_logger_maybe_fsync(logger, logger->lsn, do_fsync, true);
}

static int toku_log_fread_begin_checkpoint (FILE *infile, uint32_t len1, struct logtype_begin_checkpoint *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint64_t        (infile, &data->timestamp       , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID           (infile, &data->last_xid        , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_end_checkpoint (FILE *infile, uint32_t len1, struct logtype_end_checkpoint *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_LSN             (infile, &data->lsn_begin_checkpoint, checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint64_t        (infile, &data->timestamp       , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint32_t        (infile, &data->num_fassociate_entries, checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint32_t        (infile, &data->num_xstillopen_entries, checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_fassociate (FILE *infile, uint32_t len1, struct logtype_fassociate *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUM         (infile, &data->filenum         , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint32_t        (infile, &data->treeflags       , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->iname           , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint8_t         (infile, &data->unlink_on_close , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_xstillopen (FILE *infile, uint32_t len1, struct logtype_xstillopen *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->parentxid       , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint64_t        (infile, &data->rollentry_raw_count, checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUMS        (infile, &data->open_filenums   , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint8_t         (infile, &data->force_fsync_on_commit, checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint64_t        (infile, &data->num_rollback_nodes, checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint64_t        (infile, &data->num_rollentries , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BLOCKNUM        (infile, &data->spilled_rollback_head, checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BLOCKNUM        (infile, &data->spilled_rollback_tail, checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BLOCKNUM        (infile, &data->current_rollback, checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_xstillopenprepared (FILE *infile, uint32_t len1, struct logtype_xstillopenprepared *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_XIDP            (infile, &data->xa_xid          , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint64_t        (infile, &data->rollentry_raw_count, checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUMS        (infile, &data->open_filenums   , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint8_t         (infile, &data->force_fsync_on_commit, checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint64_t        (infile, &data->num_rollback_nodes, checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint64_t        (infile, &data->num_rollentries , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BLOCKNUM        (infile, &data->spilled_rollback_head, checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BLOCKNUM        (infile, &data->spilled_rollback_tail, checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BLOCKNUM        (infile, &data->current_rollback, checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_xbegin (FILE *infile, uint32_t len1, struct logtype_xbegin *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->parentxid       , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_xcommit (FILE *infile, uint32_t len1, struct logtype_xcommit *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_xprepare (FILE *infile, uint32_t len1, struct logtype_xprepare *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_XIDP            (infile, &data->xa_xid          , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_xabort (FILE *infile, uint32_t len1, struct logtype_xabort *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_fcreate (FILE *infile, uint32_t len1, struct logtype_fcreate *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUM         (infile, &data->filenum         , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->iname           , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint32_t        (infile, &data->mode            , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint32_t        (infile, &data->treeflags       , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint32_t        (infile, &data->nodesize        , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint32_t        (infile, &data->basementnodesize, checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint32_t        (infile, &data->compression_method, checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_fopen (FILE *infile, uint32_t len1, struct logtype_fopen *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->iname           , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUM         (infile, &data->filenum         , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint32_t        (infile, &data->treeflags       , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_fclose (FILE *infile, uint32_t len1, struct logtype_fclose *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->iname           , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUM         (infile, &data->filenum         , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_fdelete (FILE *infile, uint32_t len1, struct logtype_fdelete *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUM         (infile, &data->filenum         , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_enq_insert (FILE *infile, uint32_t len1, struct logtype_enq_insert *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUM         (infile, &data->filenum         , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->key             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->value           , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_enq_insert_no_overwrite (FILE *infile, uint32_t len1, struct logtype_enq_insert_no_overwrite *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUM         (infile, &data->filenum         , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->key             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->value           , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_enq_delete_any (FILE *infile, uint32_t len1, struct logtype_enq_delete_any *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUM         (infile, &data->filenum         , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->key             , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_enq_insert_multiple (FILE *infile, uint32_t len1, struct logtype_enq_insert_multiple *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUM         (infile, &data->src_filenum     , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUMS        (infile, &data->dest_filenums   , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->src_key         , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->src_val         , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_enq_delete_multiple (FILE *infile, uint32_t len1, struct logtype_enq_delete_multiple *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUM         (infile, &data->src_filenum     , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUMS        (infile, &data->dest_filenums   , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->src_key         , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->src_val         , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_comment (FILE *infile, uint32_t len1, struct logtype_comment *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint64_t        (infile, &data->timestamp       , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->comment         , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_enq_delete_multi (FILE *infile, uint32_t len1, struct logtype_enq_delete_multi *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUM         (infile, &data->filenum         , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->min_key         , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->max_key         , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_bool            (infile, &data->is_right_excl   , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint32_t        (infile, &data->pm_status       , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_bool            (infile, &data->is_resetting_op , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_enq_unbound_insert (FILE *infile, uint32_t len1, struct logtype_enq_unbound_insert *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUM         (infile, &data->filenum         , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->key             , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_sync_unbound_insert (FILE *infile, uint32_t len1, struct logtype_sync_unbound_insert *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_MSN             (infile, &data->msn_in_tree     , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_LSN             (infile, &data->lsn_of_enq      , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_DISKOFF         (infile, &data->offset          , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_DISKOFF         (infile, &data->size            , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_shutdown_up_to_19 (FILE *infile, uint32_t len1, struct logtype_shutdown_up_to_19 *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint64_t        (infile, &data->timestamp       , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_shutdown (FILE *infile, uint32_t len1, struct logtype_shutdown *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_uint64_t        (infile, &data->timestamp       , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID           (infile, &data->last_xid        , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_load (FILE *infile, uint32_t len1, struct logtype_load *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUM         (infile, &data->old_filenum     , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->new_iname       , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_hot_index (FILE *infile, uint32_t len1, struct logtype_hot_index *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUMS        (infile, &data->hot_index_filenums, checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_enq_update (FILE *infile, uint32_t len1, struct logtype_enq_update *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUM         (infile, &data->filenum         , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->key             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->extra           , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_enq_updatebroadcast (FILE *infile, uint32_t len1, struct logtype_enq_updatebroadcast *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUM         (infile, &data->filenum         , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->extra           , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_bool            (infile, &data->is_resetting_op , checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

static int toku_log_fread_change_fdescriptor (FILE *infile, uint32_t len1, struct logtype_change_fdescriptor *data, struct x1764 *checksum) {
  int r=0;
  uint32_t actual_len=5; // 1 for the command, 4 for the first len.
  r=toku_fread_LSN             (infile, &data->lsn             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_FILENUM         (infile, &data->filenum         , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_TXNID_PAIR      (infile, &data->xid             , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->old_descriptor  , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_BYTESTRING      (infile, &data->new_descriptor  , checksum, &actual_len); if (r!=0) return r;
  r=toku_fread_bool            (infile, &data->update_cmp_descriptor, checksum, &actual_len); if (r!=0) return r;
  uint32_t checksum_in_file, len_in_file;
  r=toku_fread_uint32_t_nocrclen(infile, &checksum_in_file); actual_len+=4;   if (r!=0) return r;
  r=toku_fread_uint32_t_nocrclen(infile, &len_in_file);    actual_len+=4;   if (r!=0) return r;
  if (checksum_in_file!=x1764_finish(checksum) || len_in_file!=actual_len || len1 != len_in_file) return DB_BADFORMAT;
  return 0;
}

int toku_log_fread (FILE *infile, struct log_entry *le) {
  uint32_t len1; int r;
  uint32_t ignorelen=0;
  struct x1764 checksum;
  x1764_init(&checksum);
  r = toku_fread_uint32_t(infile, &len1, &checksum, &ignorelen); if (r!=0) return r;
  int cmd=fgetc(infile);
  if (cmd==EOF) return EOF;
  char cmdchar = (char)cmd;
  x1764_add(&checksum, &cmdchar, 1);
  le->cmd=(enum lt_cmd)cmd;
  switch ((enum lt_cmd)cmd) {
  case LT_begin_checkpoint:
    return toku_log_fread_begin_checkpoint (infile, len1, &le->u.begin_checkpoint, &checksum);
  case LT_end_checkpoint:
    return toku_log_fread_end_checkpoint (infile, len1, &le->u.end_checkpoint, &checksum);
  case LT_fassociate:
    return toku_log_fread_fassociate (infile, len1, &le->u.fassociate, &checksum);
  case LT_xstillopen:
    return toku_log_fread_xstillopen (infile, len1, &le->u.xstillopen, &checksum);
  case LT_xstillopenprepared:
    return toku_log_fread_xstillopenprepared (infile, len1, &le->u.xstillopenprepared, &checksum);
  case LT_xbegin:
    return toku_log_fread_xbegin (infile, len1, &le->u.xbegin, &checksum);
  case LT_xcommit:
    return toku_log_fread_xcommit (infile, len1, &le->u.xcommit, &checksum);
  case LT_xprepare:
    return toku_log_fread_xprepare (infile, len1, &le->u.xprepare, &checksum);
  case LT_xabort:
    return toku_log_fread_xabort (infile, len1, &le->u.xabort, &checksum);
  case LT_fcreate:
    return toku_log_fread_fcreate (infile, len1, &le->u.fcreate, &checksum);
  case LT_fopen:
    return toku_log_fread_fopen (infile, len1, &le->u.fopen, &checksum);
  case LT_fclose:
    return toku_log_fread_fclose (infile, len1, &le->u.fclose, &checksum);
  case LT_fdelete:
    return toku_log_fread_fdelete (infile, len1, &le->u.fdelete, &checksum);
  case LT_enq_insert:
    return toku_log_fread_enq_insert (infile, len1, &le->u.enq_insert, &checksum);
  case LT_enq_insert_no_overwrite:
    return toku_log_fread_enq_insert_no_overwrite (infile, len1, &le->u.enq_insert_no_overwrite, &checksum);
  case LT_enq_delete_any:
    return toku_log_fread_enq_delete_any (infile, len1, &le->u.enq_delete_any, &checksum);
  case LT_enq_insert_multiple:
    return toku_log_fread_enq_insert_multiple (infile, len1, &le->u.enq_insert_multiple, &checksum);
  case LT_enq_delete_multiple:
    return toku_log_fread_enq_delete_multiple (infile, len1, &le->u.enq_delete_multiple, &checksum);
  case LT_comment:
    return toku_log_fread_comment (infile, len1, &le->u.comment, &checksum);
  case LT_enq_delete_multi:
    return toku_log_fread_enq_delete_multi (infile, len1, &le->u.enq_delete_multi, &checksum);
  case LT_enq_unbound_insert:
    return toku_log_fread_enq_unbound_insert (infile, len1, &le->u.enq_unbound_insert, &checksum);
  case LT_sync_unbound_insert:
    return toku_log_fread_sync_unbound_insert (infile, len1, &le->u.sync_unbound_insert, &checksum);
  case LT_shutdown_up_to_19:
    return toku_log_fread_shutdown_up_to_19 (infile, len1, &le->u.shutdown_up_to_19, &checksum);
  case LT_shutdown:
    return toku_log_fread_shutdown (infile, len1, &le->u.shutdown, &checksum);
  case LT_load:
    return toku_log_fread_load (infile, len1, &le->u.load, &checksum);
  case LT_hot_index:
    return toku_log_fread_hot_index (infile, len1, &le->u.hot_index, &checksum);
  case LT_enq_update:
    return toku_log_fread_enq_update (infile, len1, &le->u.enq_update, &checksum);
  case LT_enq_updatebroadcast:
    return toku_log_fread_enq_updatebroadcast (infile, len1, &le->u.enq_updatebroadcast, &checksum);
  case LT_change_fdescriptor:
    return toku_log_fread_change_fdescriptor (infile, len1, &le->u.change_fdescriptor, &checksum);
  };
  return DB_BADFORMAT;
}

// Return 0 if there is something to read, -1 if nothing to read, >0 on error
int toku_log_fread_backward (FILE *infile, struct log_entry *le){
  memset(le, 0, sizeof(*le));
  long pos = ftell(infile);
  if (pos<=12) return -1;
  int r = fseek(infile, -4, SEEK_CUR); 
  if (r!=0) return 1;
  uint32_t len;
  r = toku_fread_uint32_t_nocrclen(infile, &len); 
  if (r!=0) return 1;
  r = fseek(infile, -(int)len, SEEK_CUR) ;  
  if (r!=0) return 1;
  r = toku_log_fread(infile, le); 
  if (r!=0) return 1;
  long afterpos = ftell(infile);
  if (afterpos != pos) return 1;
  r = fseek(infile, -(int)len, SEEK_CUR); 
  if (r!=0) return 1;
  return 0;
}

static void toku_log_free_log_entry_begin_checkpoint_resources (struct logtype_begin_checkpoint *data) {
    toku_free_uint64_t(data->timestamp);
    toku_free_TXNID(data->last_xid);
}

static void toku_log_free_log_entry_end_checkpoint_resources (struct logtype_end_checkpoint *data) {
    toku_free_LSN(data->lsn_begin_checkpoint);
    toku_free_uint64_t(data->timestamp);
    toku_free_uint32_t(data->num_fassociate_entries);
    toku_free_uint32_t(data->num_xstillopen_entries);
}

static void toku_log_free_log_entry_fassociate_resources (struct logtype_fassociate *data) {
    toku_free_FILENUM(data->filenum);
    toku_free_uint32_t(data->treeflags);
    toku_free_BYTESTRING(data->iname);
    toku_free_uint8_t(data->unlink_on_close);
}

static void toku_log_free_log_entry_xstillopen_resources (struct logtype_xstillopen *data) {
    toku_free_TXNID_PAIR(data->xid);
    toku_free_TXNID_PAIR(data->parentxid);
    toku_free_uint64_t(data->rollentry_raw_count);
    toku_free_FILENUMS(data->open_filenums);
    toku_free_uint8_t(data->force_fsync_on_commit);
    toku_free_uint64_t(data->num_rollback_nodes);
    toku_free_uint64_t(data->num_rollentries);
    toku_free_BLOCKNUM(data->spilled_rollback_head);
    toku_free_BLOCKNUM(data->spilled_rollback_tail);
    toku_free_BLOCKNUM(data->current_rollback);
}

static void toku_log_free_log_entry_xstillopenprepared_resources (struct logtype_xstillopenprepared *data) {
    toku_free_TXNID_PAIR(data->xid);
    toku_free_XIDP(data->xa_xid);
    toku_free_uint64_t(data->rollentry_raw_count);
    toku_free_FILENUMS(data->open_filenums);
    toku_free_uint8_t(data->force_fsync_on_commit);
    toku_free_uint64_t(data->num_rollback_nodes);
    toku_free_uint64_t(data->num_rollentries);
    toku_free_BLOCKNUM(data->spilled_rollback_head);
    toku_free_BLOCKNUM(data->spilled_rollback_tail);
    toku_free_BLOCKNUM(data->current_rollback);
}

static void toku_log_free_log_entry_xbegin_resources (struct logtype_xbegin *data) {
    toku_free_TXNID_PAIR(data->xid);
    toku_free_TXNID_PAIR(data->parentxid);
}

static void toku_log_free_log_entry_xcommit_resources (struct logtype_xcommit *data) {
    toku_free_TXNID_PAIR(data->xid);
}

static void toku_log_free_log_entry_xprepare_resources (struct logtype_xprepare *data) {
    toku_free_TXNID_PAIR(data->xid);
    toku_free_XIDP(data->xa_xid);
}

static void toku_log_free_log_entry_xabort_resources (struct logtype_xabort *data) {
    toku_free_TXNID_PAIR(data->xid);
}

static void toku_log_free_log_entry_fcreate_resources (struct logtype_fcreate *data) {
    toku_free_TXNID_PAIR(data->xid);
    toku_free_FILENUM(data->filenum);
    toku_free_BYTESTRING(data->iname);
    toku_free_uint32_t(data->mode);
    toku_free_uint32_t(data->treeflags);
    toku_free_uint32_t(data->nodesize);
    toku_free_uint32_t(data->basementnodesize);
    toku_free_uint32_t(data->compression_method);
}

static void toku_log_free_log_entry_fopen_resources (struct logtype_fopen *data) {
    toku_free_BYTESTRING(data->iname);
    toku_free_FILENUM(data->filenum);
    toku_free_uint32_t(data->treeflags);
}

static void toku_log_free_log_entry_fclose_resources (struct logtype_fclose *data) {
    toku_free_BYTESTRING(data->iname);
    toku_free_FILENUM(data->filenum);
}

static void toku_log_free_log_entry_fdelete_resources (struct logtype_fdelete *data) {
    toku_free_TXNID_PAIR(data->xid);
    toku_free_FILENUM(data->filenum);
}

static void toku_log_free_log_entry_enq_insert_resources (struct logtype_enq_insert *data) {
    toku_free_FILENUM(data->filenum);
    toku_free_TXNID_PAIR(data->xid);
    toku_free_BYTESTRING(data->key);
    toku_free_BYTESTRING(data->value);
}

static void toku_log_free_log_entry_enq_insert_no_overwrite_resources (struct logtype_enq_insert_no_overwrite *data) {
    toku_free_FILENUM(data->filenum);
    toku_free_TXNID_PAIR(data->xid);
    toku_free_BYTESTRING(data->key);
    toku_free_BYTESTRING(data->value);
}

static void toku_log_free_log_entry_enq_delete_any_resources (struct logtype_enq_delete_any *data) {
    toku_free_FILENUM(data->filenum);
    toku_free_TXNID_PAIR(data->xid);
    toku_free_BYTESTRING(data->key);
}

static void toku_log_free_log_entry_enq_insert_multiple_resources (struct logtype_enq_insert_multiple *data) {
    toku_free_FILENUM(data->src_filenum);
    toku_free_FILENUMS(data->dest_filenums);
    toku_free_TXNID_PAIR(data->xid);
    toku_free_BYTESTRING(data->src_key);
    toku_free_BYTESTRING(data->src_val);
}

static void toku_log_free_log_entry_enq_delete_multiple_resources (struct logtype_enq_delete_multiple *data) {
    toku_free_FILENUM(data->src_filenum);
    toku_free_FILENUMS(data->dest_filenums);
    toku_free_TXNID_PAIR(data->xid);
    toku_free_BYTESTRING(data->src_key);
    toku_free_BYTESTRING(data->src_val);
}

static void toku_log_free_log_entry_comment_resources (struct logtype_comment *data) {
    toku_free_uint64_t(data->timestamp);
    toku_free_BYTESTRING(data->comment);
}

static void toku_log_free_log_entry_enq_delete_multi_resources (struct logtype_enq_delete_multi *data) {
    toku_free_FILENUM(data->filenum);
    toku_free_TXNID_PAIR(data->xid);
    toku_free_BYTESTRING(data->min_key);
    toku_free_BYTESTRING(data->max_key);
    toku_free_bool(data->is_right_excl);
    toku_free_uint32_t(data->pm_status);
    toku_free_bool(data->is_resetting_op);
}

static void toku_log_free_log_entry_enq_unbound_insert_resources (struct logtype_enq_unbound_insert *data) {
    toku_free_FILENUM(data->filenum);
    toku_free_TXNID_PAIR(data->xid);
    toku_free_BYTESTRING(data->key);
}

static void toku_log_free_log_entry_sync_unbound_insert_resources (struct logtype_sync_unbound_insert *data) {
    toku_free_MSN(data->msn_in_tree);
    toku_free_LSN(data->lsn_of_enq);
    toku_free_DISKOFF(data->offset);
    toku_free_DISKOFF(data->size);
}

static void toku_log_free_log_entry_shutdown_up_to_19_resources (struct logtype_shutdown_up_to_19 *data) {
    toku_free_uint64_t(data->timestamp);
}

static void toku_log_free_log_entry_shutdown_resources (struct logtype_shutdown *data) {
    toku_free_uint64_t(data->timestamp);
    toku_free_TXNID(data->last_xid);
}

static void toku_log_free_log_entry_load_resources (struct logtype_load *data) {
    toku_free_TXNID_PAIR(data->xid);
    toku_free_FILENUM(data->old_filenum);
    toku_free_BYTESTRING(data->new_iname);
}

static void toku_log_free_log_entry_hot_index_resources (struct logtype_hot_index *data) {
    toku_free_TXNID_PAIR(data->xid);
    toku_free_FILENUMS(data->hot_index_filenums);
}

static void toku_log_free_log_entry_enq_update_resources (struct logtype_enq_update *data) {
    toku_free_FILENUM(data->filenum);
    toku_free_TXNID_PAIR(data->xid);
    toku_free_BYTESTRING(data->key);
    toku_free_BYTESTRING(data->extra);
}

static void toku_log_free_log_entry_enq_updatebroadcast_resources (struct logtype_enq_updatebroadcast *data) {
    toku_free_FILENUM(data->filenum);
    toku_free_TXNID_PAIR(data->xid);
    toku_free_BYTESTRING(data->extra);
    toku_free_bool(data->is_resetting_op);
}

static void toku_log_free_log_entry_change_fdescriptor_resources (struct logtype_change_fdescriptor *data) {
    toku_free_FILENUM(data->filenum);
    toku_free_TXNID_PAIR(data->xid);
    toku_free_BYTESTRING(data->old_descriptor);
    toku_free_BYTESTRING(data->new_descriptor);
    toku_free_bool(data->update_cmp_descriptor);
}

void toku_log_free_log_entry_resources (struct log_entry *le) {
    switch ((enum lt_cmd)le->cmd) {
    case LT_begin_checkpoint:
        return toku_log_free_log_entry_begin_checkpoint_resources (&(le->u.begin_checkpoint));
    case LT_end_checkpoint:
        return toku_log_free_log_entry_end_checkpoint_resources (&(le->u.end_checkpoint));
    case LT_fassociate:
        return toku_log_free_log_entry_fassociate_resources (&(le->u.fassociate));
    case LT_xstillopen:
        return toku_log_free_log_entry_xstillopen_resources (&(le->u.xstillopen));
    case LT_xstillopenprepared:
        return toku_log_free_log_entry_xstillopenprepared_resources (&(le->u.xstillopenprepared));
    case LT_xbegin:
        return toku_log_free_log_entry_xbegin_resources (&(le->u.xbegin));
    case LT_xcommit:
        return toku_log_free_log_entry_xcommit_resources (&(le->u.xcommit));
    case LT_xprepare:
        return toku_log_free_log_entry_xprepare_resources (&(le->u.xprepare));
    case LT_xabort:
        return toku_log_free_log_entry_xabort_resources (&(le->u.xabort));
    case LT_fcreate:
        return toku_log_free_log_entry_fcreate_resources (&(le->u.fcreate));
    case LT_fopen:
        return toku_log_free_log_entry_fopen_resources (&(le->u.fopen));
    case LT_fclose:
        return toku_log_free_log_entry_fclose_resources (&(le->u.fclose));
    case LT_fdelete:
        return toku_log_free_log_entry_fdelete_resources (&(le->u.fdelete));
    case LT_enq_insert:
        return toku_log_free_log_entry_enq_insert_resources (&(le->u.enq_insert));
    case LT_enq_insert_no_overwrite:
        return toku_log_free_log_entry_enq_insert_no_overwrite_resources (&(le->u.enq_insert_no_overwrite));
    case LT_enq_delete_any:
        return toku_log_free_log_entry_enq_delete_any_resources (&(le->u.enq_delete_any));
    case LT_enq_insert_multiple:
        return toku_log_free_log_entry_enq_insert_multiple_resources (&(le->u.enq_insert_multiple));
    case LT_enq_delete_multiple:
        return toku_log_free_log_entry_enq_delete_multiple_resources (&(le->u.enq_delete_multiple));
    case LT_comment:
        return toku_log_free_log_entry_comment_resources (&(le->u.comment));
    case LT_enq_delete_multi:
        return toku_log_free_log_entry_enq_delete_multi_resources (&(le->u.enq_delete_multi));
    case LT_enq_unbound_insert:
        return toku_log_free_log_entry_enq_unbound_insert_resources (&(le->u.enq_unbound_insert));
    case LT_sync_unbound_insert:
        return toku_log_free_log_entry_sync_unbound_insert_resources (&(le->u.sync_unbound_insert));
    case LT_shutdown_up_to_19:
        return toku_log_free_log_entry_shutdown_up_to_19_resources (&(le->u.shutdown_up_to_19));
    case LT_shutdown:
        return toku_log_free_log_entry_shutdown_resources (&(le->u.shutdown));
    case LT_load:
        return toku_log_free_log_entry_load_resources (&(le->u.load));
    case LT_hot_index:
        return toku_log_free_log_entry_hot_index_resources (&(le->u.hot_index));
    case LT_enq_update:
        return toku_log_free_log_entry_enq_update_resources (&(le->u.enq_update));
    case LT_enq_updatebroadcast:
        return toku_log_free_log_entry_enq_updatebroadcast_resources (&(le->u.enq_updatebroadcast));
    case LT_change_fdescriptor:
        return toku_log_free_log_entry_change_fdescriptor_resources (&(le->u.change_fdescriptor));
    };
    return;
}

void toku_logger_save_rollback_fdelete (TOKUTXN txn, FILENUM filenum) {
  toku_txn_lock(txn);
  ROLLBACK_LOG_NODE log;
  toku_get_and_pin_rollback_log_for_new_entry(txn, &log);
  uint32_t rollback_fsize = toku_logger_rollback_fsize_fdelete(filenum);
  struct roll_entry *v;
  size_t mem_needed = sizeof(v->u.fdelete) + __builtin_offsetof(struct roll_entry, u.fdelete);
  CAST_FROM_VOIDP(v, toku_malloc_in_rollback(log, mem_needed));
  assert(v);
  v->cmd = (enum rt_cmd)85;
  v->u.fdelete.filenum = filenum;
  v->prev = log->newest_logentry;
  if (log->oldest_logentry==NULL) log->oldest_logentry=v;
  log->newest_logentry = v;
  log->rollentry_resident_bytecount += rollback_fsize;
  txn->roll_info.rollentry_raw_count          += rollback_fsize;
  txn->roll_info.num_rollentries++;
  log->dirty = true;
  // spill and unpin assert success internally
  toku_maybe_spill_rollbacks(txn, log);
  toku_rollback_log_unpin(txn, log);
  toku_txn_unlock(txn);
}
void toku_logger_save_rollback_fcreate (TOKUTXN txn, FILENUM filenum, BYTESTRING *iname_ptr) {
  toku_txn_lock(txn);
  ROLLBACK_LOG_NODE log;
  toku_get_and_pin_rollback_log_for_new_entry(txn, &log);
  BYTESTRING iname   = {
    .len  = iname_ptr->len,
    .data = cast_to_typeof(iname.data) toku_memdup_in_rollback(log, iname_ptr->data, iname_ptr->len)
  };
  uint32_t rollback_fsize = toku_logger_rollback_fsize_fcreate(filenum, iname);
  struct roll_entry *v;
  size_t mem_needed = sizeof(v->u.fcreate) + __builtin_offsetof(struct roll_entry, u.fcreate);
  CAST_FROM_VOIDP(v, toku_malloc_in_rollback(log, mem_needed));
  assert(v);
  v->cmd = (enum rt_cmd)70;
  v->u.fcreate.filenum = filenum;
  v->u.fcreate.iname = iname;
  v->prev = log->newest_logentry;
  if (log->oldest_logentry==NULL) log->oldest_logentry=v;
  log->newest_logentry = v;
  log->rollentry_resident_bytecount += rollback_fsize;
  txn->roll_info.rollentry_raw_count          += rollback_fsize;
  txn->roll_info.num_rollentries++;
  log->dirty = true;
  // spill and unpin assert success internally
  toku_maybe_spill_rollbacks(txn, log);
  toku_rollback_log_unpin(txn, log);
  toku_txn_unlock(txn);
}
void toku_logger_save_rollback_cmdinsert (TOKUTXN txn, FILENUM filenum, BYTESTRING *key_ptr) {
  toku_txn_lock(txn);
  ROLLBACK_LOG_NODE log;
  toku_get_and_pin_rollback_log_for_new_entry(txn, &log);
  BYTESTRING key   = {
    .len  = key_ptr->len,
    .data = cast_to_typeof(key.data) toku_memdup_in_rollback(log, key_ptr->data, key_ptr->len)
  };
  uint32_t rollback_fsize = toku_logger_rollback_fsize_cmdinsert(filenum, key);
  struct roll_entry *v;
  size_t mem_needed = sizeof(v->u.cmdinsert) + __builtin_offsetof(struct roll_entry, u.cmdinsert);
  CAST_FROM_VOIDP(v, toku_malloc_in_rollback(log, mem_needed));
  assert(v);
  v->cmd = (enum rt_cmd)105;
  v->u.cmdinsert.filenum = filenum;
  v->u.cmdinsert.key = key;
  v->prev = log->newest_logentry;
  if (log->oldest_logentry==NULL) log->oldest_logentry=v;
  log->newest_logentry = v;
  log->rollentry_resident_bytecount += rollback_fsize;
  txn->roll_info.rollentry_raw_count          += rollback_fsize;
  txn->roll_info.num_rollentries++;
  log->dirty = true;
  // spill and unpin assert success internally
  toku_maybe_spill_rollbacks(txn, log);
  toku_rollback_log_unpin(txn, log);
  toku_txn_unlock(txn);
}
void toku_logger_save_rollback_cmdseqinsert (TOKUTXN txn, FILENUM filenum, BYTESTRING *key_ptr) {
  toku_txn_lock(txn);
  ROLLBACK_LOG_NODE log;
  toku_get_and_pin_rollback_log_for_new_entry(txn, &log);
  BYTESTRING key   = {
    .len  = key_ptr->len,
    .data = cast_to_typeof(key.data) toku_memdup_in_rollback(log, key_ptr->data, key_ptr->len)
  };
  uint32_t rollback_fsize = toku_logger_rollback_fsize_cmdseqinsert(filenum, key);
  struct roll_entry *v;
  size_t mem_needed = sizeof(v->u.cmdseqinsert) + __builtin_offsetof(struct roll_entry, u.cmdseqinsert);
  CAST_FROM_VOIDP(v, toku_malloc_in_rollback(log, mem_needed));
  assert(v);
  v->cmd = (enum rt_cmd)103;
  v->u.cmdseqinsert.filenum = filenum;
  v->u.cmdseqinsert.key = key;
  v->prev = log->newest_logentry;
  if (log->oldest_logentry==NULL) log->oldest_logentry=v;
  log->newest_logentry = v;
  log->rollentry_resident_bytecount += rollback_fsize;
  txn->roll_info.rollentry_raw_count          += rollback_fsize;
  txn->roll_info.num_rollentries++;
  log->dirty = true;
  // spill and unpin assert success internally
  toku_maybe_spill_rollbacks(txn, log);
  toku_rollback_log_unpin(txn, log);
  toku_txn_unlock(txn);
}
void toku_logger_save_rollback_cmddelete (TOKUTXN txn, FILENUM filenum, BYTESTRING *key_ptr) {
  toku_txn_lock(txn);
  ROLLBACK_LOG_NODE log;
  toku_get_and_pin_rollback_log_for_new_entry(txn, &log);
  BYTESTRING key   = {
    .len  = key_ptr->len,
    .data = cast_to_typeof(key.data) toku_memdup_in_rollback(log, key_ptr->data, key_ptr->len)
  };
  uint32_t rollback_fsize = toku_logger_rollback_fsize_cmddelete(filenum, key);
  struct roll_entry *v;
  size_t mem_needed = sizeof(v->u.cmddelete) + __builtin_offsetof(struct roll_entry, u.cmddelete);
  CAST_FROM_VOIDP(v, toku_malloc_in_rollback(log, mem_needed));
  assert(v);
  v->cmd = (enum rt_cmd)100;
  v->u.cmddelete.filenum = filenum;
  v->u.cmddelete.key = key;
  v->prev = log->newest_logentry;
  if (log->oldest_logentry==NULL) log->oldest_logentry=v;
  log->newest_logentry = v;
  log->rollentry_resident_bytecount += rollback_fsize;
  txn->roll_info.rollentry_raw_count          += rollback_fsize;
  txn->roll_info.num_rollentries++;
  log->dirty = true;
  // spill and unpin assert success internally
  toku_maybe_spill_rollbacks(txn, log);
  toku_rollback_log_unpin(txn, log);
  toku_txn_unlock(txn);
}
void toku_logger_save_rollback_cmddeletemulti (TOKUTXN txn, FILENUM filenum, BYTESTRING *min_key_ptr, BYTESTRING *max_key_ptr, bool is_right_excl, uint32_t pm_status, bool is_resetting_op) {
  toku_txn_lock(txn);
  ROLLBACK_LOG_NODE log;
  toku_get_and_pin_rollback_log_for_new_entry(txn, &log);
  BYTESTRING min_key   = {
    .len  = min_key_ptr->len,
    .data = cast_to_typeof(min_key.data) toku_memdup_in_rollback(log, min_key_ptr->data, min_key_ptr->len)
  };
  BYTESTRING max_key   = {
    .len  = max_key_ptr->len,
    .data = cast_to_typeof(max_key.data) toku_memdup_in_rollback(log, max_key_ptr->data, max_key_ptr->len)
  };
  uint32_t rollback_fsize = toku_logger_rollback_fsize_cmddeletemulti(filenum, min_key, max_key, is_right_excl, pm_status, is_resetting_op);
  struct roll_entry *v;
  size_t mem_needed = sizeof(v->u.cmddeletemulti) + __builtin_offsetof(struct roll_entry, u.cmddeletemulti);
  CAST_FROM_VOIDP(v, toku_malloc_in_rollback(log, mem_needed));
  assert(v);
  v->cmd = (enum rt_cmd)90;
  v->u.cmddeletemulti.filenum = filenum;
  v->u.cmddeletemulti.min_key = min_key;
  v->u.cmddeletemulti.max_key = max_key;
  v->u.cmddeletemulti.is_right_excl = is_right_excl;
  v->u.cmddeletemulti.pm_status = pm_status;
  v->u.cmddeletemulti.is_resetting_op = is_resetting_op;
  v->prev = log->newest_logentry;
  if (log->oldest_logentry==NULL) log->oldest_logentry=v;
  log->newest_logentry = v;
  log->rollentry_resident_bytecount += rollback_fsize;
  txn->roll_info.rollentry_raw_count          += rollback_fsize;
  txn->roll_info.num_rollentries++;
  log->dirty = true;
  // spill and unpin assert success internally
  toku_maybe_spill_rollbacks(txn, log);
  toku_rollback_log_unpin(txn, log);
  toku_txn_unlock(txn);
}
void toku_logger_save_rollback_rollinclude (TOKUTXN txn, TXNID_PAIR xid, uint64_t num_nodes, BLOCKNUM spilled_head, BLOCKNUM spilled_tail) {
  toku_txn_lock(txn);
  ROLLBACK_LOG_NODE log;
  toku_get_and_pin_rollback_log_for_new_entry(txn, &log);
  uint32_t rollback_fsize = toku_logger_rollback_fsize_rollinclude(xid, num_nodes, spilled_head, spilled_tail);
  struct roll_entry *v;
  size_t mem_needed = sizeof(v->u.rollinclude) + __builtin_offsetof(struct roll_entry, u.rollinclude);
  CAST_FROM_VOIDP(v, toku_malloc_in_rollback(log, mem_needed));
  assert(v);
  v->cmd = (enum rt_cmd)114;
  v->u.rollinclude.xid = xid;
  v->u.rollinclude.num_nodes = num_nodes;
  v->u.rollinclude.spilled_head = spilled_head;
  v->u.rollinclude.spilled_tail = spilled_tail;
  v->prev = log->newest_logentry;
  if (log->oldest_logentry==NULL) log->oldest_logentry=v;
  log->newest_logentry = v;
  log->rollentry_resident_bytecount += rollback_fsize;
  txn->roll_info.rollentry_raw_count          += rollback_fsize;
  txn->roll_info.num_rollentries++;
  log->dirty = true;
  // spill and unpin assert success internally
  toku_maybe_spill_rollbacks(txn, log);
  toku_rollback_log_unpin(txn, log);
  toku_txn_unlock(txn);
}
void toku_logger_save_rollback_load (TOKUTXN txn, FILENUM old_filenum, BYTESTRING *new_iname_ptr) {
  toku_txn_lock(txn);
  ROLLBACK_LOG_NODE log;
  toku_get_and_pin_rollback_log_for_new_entry(txn, &log);
  BYTESTRING new_iname   = {
    .len  = new_iname_ptr->len,
    .data = cast_to_typeof(new_iname.data) toku_memdup_in_rollback(log, new_iname_ptr->data, new_iname_ptr->len)
  };
  uint32_t rollback_fsize = toku_logger_rollback_fsize_load(old_filenum, new_iname);
  struct roll_entry *v;
  size_t mem_needed = sizeof(v->u.load) + __builtin_offsetof(struct roll_entry, u.load);
  CAST_FROM_VOIDP(v, toku_malloc_in_rollback(log, mem_needed));
  assert(v);
  v->cmd = (enum rt_cmd)108;
  v->u.load.old_filenum = old_filenum;
  v->u.load.new_iname = new_iname;
  v->prev = log->newest_logentry;
  if (log->oldest_logentry==NULL) log->oldest_logentry=v;
  log->newest_logentry = v;
  log->rollentry_resident_bytecount += rollback_fsize;
  txn->roll_info.rollentry_raw_count          += rollback_fsize;
  txn->roll_info.num_rollentries++;
  log->dirty = true;
  // spill and unpin assert success internally
  toku_maybe_spill_rollbacks(txn, log);
  toku_rollback_log_unpin(txn, log);
  toku_txn_unlock(txn);
}
void toku_logger_save_rollback_hot_index (TOKUTXN txn, FILENUMS *hot_index_filenums_ptr) {
  toku_txn_lock(txn);
  ROLLBACK_LOG_NODE log;
  toku_get_and_pin_rollback_log_for_new_entry(txn, &log);
  FILENUMS hot_index_filenums   = {
    .num  = hot_index_filenums_ptr->num,
    .filenums = cast_to_typeof(hot_index_filenums.filenums) toku_memdup_in_rollback(log, hot_index_filenums_ptr->filenums, hot_index_filenums_ptr->num * (sizeof (FILENUM)))
  };
  uint32_t rollback_fsize = toku_logger_rollback_fsize_hot_index(hot_index_filenums);
  struct roll_entry *v;
  size_t mem_needed = sizeof(v->u.hot_index) + __builtin_offsetof(struct roll_entry, u.hot_index);
  CAST_FROM_VOIDP(v, toku_malloc_in_rollback(log, mem_needed));
  assert(v);
  v->cmd = (enum rt_cmd)104;
  v->u.hot_index.hot_index_filenums = hot_index_filenums;
  v->prev = log->newest_logentry;
  if (log->oldest_logentry==NULL) log->oldest_logentry=v;
  log->newest_logentry = v;
  log->rollentry_resident_bytecount += rollback_fsize;
  txn->roll_info.rollentry_raw_count          += rollback_fsize;
  txn->roll_info.num_rollentries++;
  log->dirty = true;
  // spill and unpin assert success internally
  toku_maybe_spill_rollbacks(txn, log);
  toku_rollback_log_unpin(txn, log);
  toku_txn_unlock(txn);
}
void toku_logger_save_rollback_dictionary_redirect (TOKUTXN txn, FILENUM old_filenum, FILENUM new_filenum) {
  toku_txn_lock(txn);
  ROLLBACK_LOG_NODE log;
  toku_get_and_pin_rollback_log_for_new_entry(txn, &log);
  uint32_t rollback_fsize = toku_logger_rollback_fsize_dictionary_redirect(old_filenum, new_filenum);
  struct roll_entry *v;
  size_t mem_needed = sizeof(v->u.dictionary_redirect) + __builtin_offsetof(struct roll_entry, u.dictionary_redirect);
  CAST_FROM_VOIDP(v, toku_malloc_in_rollback(log, mem_needed));
  assert(v);
  v->cmd = (enum rt_cmd)82;
  v->u.dictionary_redirect.old_filenum = old_filenum;
  v->u.dictionary_redirect.new_filenum = new_filenum;
  v->prev = log->newest_logentry;
  if (log->oldest_logentry==NULL) log->oldest_logentry=v;
  log->newest_logentry = v;
  log->rollentry_resident_bytecount += rollback_fsize;
  txn->roll_info.rollentry_raw_count          += rollback_fsize;
  txn->roll_info.num_rollentries++;
  log->dirty = true;
  // spill and unpin assert success internally
  toku_maybe_spill_rollbacks(txn, log);
  toku_rollback_log_unpin(txn, log);
  toku_txn_unlock(txn);
}
void toku_logger_save_rollback_cmdupdate (TOKUTXN txn, FILENUM filenum, BYTESTRING *key_ptr) {
  toku_txn_lock(txn);
  ROLLBACK_LOG_NODE log;
  toku_get_and_pin_rollback_log_for_new_entry(txn, &log);
  BYTESTRING key   = {
    .len  = key_ptr->len,
    .data = cast_to_typeof(key.data) toku_memdup_in_rollback(log, key_ptr->data, key_ptr->len)
  };
  uint32_t rollback_fsize = toku_logger_rollback_fsize_cmdupdate(filenum, key);
  struct roll_entry *v;
  size_t mem_needed = sizeof(v->u.cmdupdate) + __builtin_offsetof(struct roll_entry, u.cmdupdate);
  CAST_FROM_VOIDP(v, toku_malloc_in_rollback(log, mem_needed));
  assert(v);
  v->cmd = (enum rt_cmd)117;
  v->u.cmdupdate.filenum = filenum;
  v->u.cmdupdate.key = key;
  v->prev = log->newest_logentry;
  if (log->oldest_logentry==NULL) log->oldest_logentry=v;
  log->newest_logentry = v;
  log->rollentry_resident_bytecount += rollback_fsize;
  txn->roll_info.rollentry_raw_count          += rollback_fsize;
  txn->roll_info.num_rollentries++;
  log->dirty = true;
  // spill and unpin assert success internally
  toku_maybe_spill_rollbacks(txn, log);
  toku_rollback_log_unpin(txn, log);
  toku_txn_unlock(txn);
}
void toku_logger_save_rollback_cmdupdatebroadcast (TOKUTXN txn, FILENUM filenum, bool is_resetting_op) {
  toku_txn_lock(txn);
  ROLLBACK_LOG_NODE log;
  toku_get_and_pin_rollback_log_for_new_entry(txn, &log);
  uint32_t rollback_fsize = toku_logger_rollback_fsize_cmdupdatebroadcast(filenum, is_resetting_op);
  struct roll_entry *v;
  size_t mem_needed = sizeof(v->u.cmdupdatebroadcast) + __builtin_offsetof(struct roll_entry, u.cmdupdatebroadcast);
  CAST_FROM_VOIDP(v, toku_malloc_in_rollback(log, mem_needed));
  assert(v);
  v->cmd = (enum rt_cmd)66;
  v->u.cmdupdatebroadcast.filenum = filenum;
  v->u.cmdupdatebroadcast.is_resetting_op = is_resetting_op;
  v->prev = log->newest_logentry;
  if (log->oldest_logentry==NULL) log->oldest_logentry=v;
  log->newest_logentry = v;
  log->rollentry_resident_bytecount += rollback_fsize;
  txn->roll_info.rollentry_raw_count          += rollback_fsize;
  txn->roll_info.num_rollentries++;
  log->dirty = true;
  // spill and unpin assert success internally
  toku_maybe_spill_rollbacks(txn, log);
  toku_rollback_log_unpin(txn, log);
  toku_txn_unlock(txn);
}
void toku_logger_save_rollback_change_fdescriptor (TOKUTXN txn, FILENUM filenum, BYTESTRING *old_descriptor_ptr) {
  toku_txn_lock(txn);
  ROLLBACK_LOG_NODE log;
  toku_get_and_pin_rollback_log_for_new_entry(txn, &log);
  BYTESTRING old_descriptor   = {
    .len  = old_descriptor_ptr->len,
    .data = cast_to_typeof(old_descriptor.data) toku_memdup_in_rollback(log, old_descriptor_ptr->data, old_descriptor_ptr->len)
  };
  uint32_t rollback_fsize = toku_logger_rollback_fsize_change_fdescriptor(filenum, old_descriptor);
  struct roll_entry *v;
  size_t mem_needed = sizeof(v->u.change_fdescriptor) + __builtin_offsetof(struct roll_entry, u.change_fdescriptor);
  CAST_FROM_VOIDP(v, toku_malloc_in_rollback(log, mem_needed));
  assert(v);
  v->cmd = (enum rt_cmd)68;
  v->u.change_fdescriptor.filenum = filenum;
  v->u.change_fdescriptor.old_descriptor = old_descriptor;
  v->prev = log->newest_logentry;
  if (log->oldest_logentry==NULL) log->oldest_logentry=v;
  log->newest_logentry = v;
  log->rollentry_resident_bytecount += rollback_fsize;
  txn->roll_info.rollentry_raw_count          += rollback_fsize;
  txn->roll_info.num_rollentries++;
  log->dirty = true;
  // spill and unpin assert success internally
  toku_maybe_spill_rollbacks(txn, log);
  toku_rollback_log_unpin(txn, log);
  toku_txn_unlock(txn);
}
void toku_logger_rollback_wbuf_nocrc_write_fdelete (struct wbuf *wbuf, FILENUM filenum) {
  uint32_t rollback_fsize = toku_logger_rollback_fsize_fdelete(filenum);
  wbuf_nocrc_int(wbuf, rollback_fsize);
  wbuf_nocrc_char(wbuf, 'U');
  wbuf_nocrc_FILENUM(wbuf, filenum);
}
void toku_logger_rollback_wbuf_nocrc_write_fcreate (struct wbuf *wbuf, FILENUM filenum, BYTESTRING iname) {
  uint32_t rollback_fsize = toku_logger_rollback_fsize_fcreate(filenum, iname);
  wbuf_nocrc_int(wbuf, rollback_fsize);
  wbuf_nocrc_char(wbuf, 'F');
  wbuf_nocrc_FILENUM(wbuf, filenum);
  wbuf_nocrc_BYTESTRING(wbuf, iname);
}
void toku_logger_rollback_wbuf_nocrc_write_cmdinsert (struct wbuf *wbuf, FILENUM filenum, BYTESTRING key) {
  uint32_t rollback_fsize = toku_logger_rollback_fsize_cmdinsert(filenum, key);
  wbuf_nocrc_int(wbuf, rollback_fsize);
  wbuf_nocrc_char(wbuf, 'i');
  wbuf_nocrc_FILENUM(wbuf, filenum);
  wbuf_nocrc_BYTESTRING(wbuf, key);
}
void toku_logger_rollback_wbuf_nocrc_write_cmdseqinsert (struct wbuf *wbuf, FILENUM filenum, BYTESTRING key) {
  uint32_t rollback_fsize = toku_logger_rollback_fsize_cmdseqinsert(filenum, key);
  wbuf_nocrc_int(wbuf, rollback_fsize);
  wbuf_nocrc_char(wbuf, 'g');
  wbuf_nocrc_FILENUM(wbuf, filenum);
  wbuf_nocrc_BYTESTRING(wbuf, key);
}
void toku_logger_rollback_wbuf_nocrc_write_cmddelete (struct wbuf *wbuf, FILENUM filenum, BYTESTRING key) {
  uint32_t rollback_fsize = toku_logger_rollback_fsize_cmddelete(filenum, key);
  wbuf_nocrc_int(wbuf, rollback_fsize);
  wbuf_nocrc_char(wbuf, 'd');
  wbuf_nocrc_FILENUM(wbuf, filenum);
  wbuf_nocrc_BYTESTRING(wbuf, key);
}
void toku_logger_rollback_wbuf_nocrc_write_cmddeletemulti (struct wbuf *wbuf, FILENUM filenum, BYTESTRING min_key, BYTESTRING max_key, bool is_right_excl, uint32_t pm_status, bool is_resetting_op) {
  uint32_t rollback_fsize = toku_logger_rollback_fsize_cmddeletemulti(filenum, min_key, max_key, is_right_excl, pm_status, is_resetting_op);
  wbuf_nocrc_int(wbuf, rollback_fsize);
  wbuf_nocrc_char(wbuf, 'Z');
  wbuf_nocrc_FILENUM(wbuf, filenum);
  wbuf_nocrc_BYTESTRING(wbuf, min_key);
  wbuf_nocrc_BYTESTRING(wbuf, max_key);
  wbuf_nocrc_bool(wbuf, is_right_excl);
  wbuf_nocrc_uint32_t(wbuf, pm_status);
  wbuf_nocrc_bool(wbuf, is_resetting_op);
}
void toku_logger_rollback_wbuf_nocrc_write_rollinclude (struct wbuf *wbuf, TXNID_PAIR xid, uint64_t num_nodes, BLOCKNUM spilled_head, BLOCKNUM spilled_tail) {
  uint32_t rollback_fsize = toku_logger_rollback_fsize_rollinclude(xid, num_nodes, spilled_head, spilled_tail);
  wbuf_nocrc_int(wbuf, rollback_fsize);
  wbuf_nocrc_char(wbuf, 'r');
  wbuf_nocrc_TXNID_PAIR(wbuf, xid);
  wbuf_nocrc_uint64_t(wbuf, num_nodes);
  wbuf_nocrc_BLOCKNUM(wbuf, spilled_head);
  wbuf_nocrc_BLOCKNUM(wbuf, spilled_tail);
}
void toku_logger_rollback_wbuf_nocrc_write_load (struct wbuf *wbuf, FILENUM old_filenum, BYTESTRING new_iname) {
  uint32_t rollback_fsize = toku_logger_rollback_fsize_load(old_filenum, new_iname);
  wbuf_nocrc_int(wbuf, rollback_fsize);
  wbuf_nocrc_char(wbuf, 'l');
  wbuf_nocrc_FILENUM(wbuf, old_filenum);
  wbuf_nocrc_BYTESTRING(wbuf, new_iname);
}
void toku_logger_rollback_wbuf_nocrc_write_hot_index (struct wbuf *wbuf, FILENUMS hot_index_filenums) {
  uint32_t rollback_fsize = toku_logger_rollback_fsize_hot_index(hot_index_filenums);
  wbuf_nocrc_int(wbuf, rollback_fsize);
  wbuf_nocrc_char(wbuf, 'h');
  wbuf_nocrc_FILENUMS(wbuf, hot_index_filenums);
}
void toku_logger_rollback_wbuf_nocrc_write_dictionary_redirect (struct wbuf *wbuf, FILENUM old_filenum, FILENUM new_filenum) {
  uint32_t rollback_fsize = toku_logger_rollback_fsize_dictionary_redirect(old_filenum, new_filenum);
  wbuf_nocrc_int(wbuf, rollback_fsize);
  wbuf_nocrc_char(wbuf, 'R');
  wbuf_nocrc_FILENUM(wbuf, old_filenum);
  wbuf_nocrc_FILENUM(wbuf, new_filenum);
}
void toku_logger_rollback_wbuf_nocrc_write_cmdupdate (struct wbuf *wbuf, FILENUM filenum, BYTESTRING key) {
  uint32_t rollback_fsize = toku_logger_rollback_fsize_cmdupdate(filenum, key);
  wbuf_nocrc_int(wbuf, rollback_fsize);
  wbuf_nocrc_char(wbuf, 'u');
  wbuf_nocrc_FILENUM(wbuf, filenum);
  wbuf_nocrc_BYTESTRING(wbuf, key);
}
void toku_logger_rollback_wbuf_nocrc_write_cmdupdatebroadcast (struct wbuf *wbuf, FILENUM filenum, bool is_resetting_op) {
  uint32_t rollback_fsize = toku_logger_rollback_fsize_cmdupdatebroadcast(filenum, is_resetting_op);
  wbuf_nocrc_int(wbuf, rollback_fsize);
  wbuf_nocrc_char(wbuf, 'B');
  wbuf_nocrc_FILENUM(wbuf, filenum);
  wbuf_nocrc_bool(wbuf, is_resetting_op);
}
void toku_logger_rollback_wbuf_nocrc_write_change_fdescriptor (struct wbuf *wbuf, FILENUM filenum, BYTESTRING old_descriptor) {
  uint32_t rollback_fsize = toku_logger_rollback_fsize_change_fdescriptor(filenum, old_descriptor);
  wbuf_nocrc_int(wbuf, rollback_fsize);
  wbuf_nocrc_char(wbuf, 'D');
  wbuf_nocrc_FILENUM(wbuf, filenum);
  wbuf_nocrc_BYTESTRING(wbuf, old_descriptor);
}
void toku_logger_rollback_wbuf_nocrc_write (struct wbuf *wbuf, struct roll_entry *r) {
  switch (r->cmd) {
    case RT_fdelete: toku_logger_rollback_wbuf_nocrc_write_fdelete(wbuf, r->u.fdelete.filenum); return;
    case RT_fcreate: toku_logger_rollback_wbuf_nocrc_write_fcreate(wbuf, r->u.fcreate.filenum, r->u.fcreate.iname); return;
    case RT_cmdinsert: toku_logger_rollback_wbuf_nocrc_write_cmdinsert(wbuf, r->u.cmdinsert.filenum, r->u.cmdinsert.key); return;
    case RT_cmdseqinsert: toku_logger_rollback_wbuf_nocrc_write_cmdseqinsert(wbuf, r->u.cmdseqinsert.filenum, r->u.cmdseqinsert.key); return;
    case RT_cmddelete: toku_logger_rollback_wbuf_nocrc_write_cmddelete(wbuf, r->u.cmddelete.filenum, r->u.cmddelete.key); return;
    case RT_cmddeletemulti: toku_logger_rollback_wbuf_nocrc_write_cmddeletemulti(wbuf, r->u.cmddeletemulti.filenum, r->u.cmddeletemulti.min_key, r->u.cmddeletemulti.max_key, r->u.cmddeletemulti.is_right_excl, r->u.cmddeletemulti.pm_status, r->u.cmddeletemulti.is_resetting_op); return;
    case RT_rollinclude: toku_logger_rollback_wbuf_nocrc_write_rollinclude(wbuf, r->u.rollinclude.xid, r->u.rollinclude.num_nodes, r->u.rollinclude.spilled_head, r->u.rollinclude.spilled_tail); return;
    case RT_load: toku_logger_rollback_wbuf_nocrc_write_load(wbuf, r->u.load.old_filenum, r->u.load.new_iname); return;
    case RT_hot_index: toku_logger_rollback_wbuf_nocrc_write_hot_index(wbuf, r->u.hot_index.hot_index_filenums); return;
    case RT_dictionary_redirect: toku_logger_rollback_wbuf_nocrc_write_dictionary_redirect(wbuf, r->u.dictionary_redirect.old_filenum, r->u.dictionary_redirect.new_filenum); return;
    case RT_cmdupdate: toku_logger_rollback_wbuf_nocrc_write_cmdupdate(wbuf, r->u.cmdupdate.filenum, r->u.cmdupdate.key); return;
    case RT_cmdupdatebroadcast: toku_logger_rollback_wbuf_nocrc_write_cmdupdatebroadcast(wbuf, r->u.cmdupdatebroadcast.filenum, r->u.cmdupdatebroadcast.is_resetting_op); return;
    case RT_change_fdescriptor: toku_logger_rollback_wbuf_nocrc_write_change_fdescriptor(wbuf, r->u.change_fdescriptor.filenum, r->u.change_fdescriptor.old_descriptor); return;
  }
  assert(0);
}
uint32_t toku_logger_rollback_fsize_fdelete (FILENUM filenum) {
  return 1 /* the cmd*/
         + 4 /* the int at the end saying the size */
         + toku_logsizeof_FILENUM(filenum);
}
uint32_t toku_logger_rollback_fsize_fcreate (FILENUM filenum, BYTESTRING iname) {
  return 1 /* the cmd*/
         + 4 /* the int at the end saying the size */
         + toku_logsizeof_FILENUM(filenum)
         + toku_logsizeof_BYTESTRING(iname);
}
uint32_t toku_logger_rollback_fsize_cmdinsert (FILENUM filenum, BYTESTRING key) {
  return 1 /* the cmd*/
         + 4 /* the int at the end saying the size */
         + toku_logsizeof_FILENUM(filenum)
         + toku_logsizeof_BYTESTRING(key);
}
uint32_t toku_logger_rollback_fsize_cmdseqinsert (FILENUM filenum, BYTESTRING key) {
  return 1 /* the cmd*/
         + 4 /* the int at the end saying the size */
         + toku_logsizeof_FILENUM(filenum)
         + toku_logsizeof_BYTESTRING(key);
}
uint32_t toku_logger_rollback_fsize_cmddelete (FILENUM filenum, BYTESTRING key) {
  return 1 /* the cmd*/
         + 4 /* the int at the end saying the size */
         + toku_logsizeof_FILENUM(filenum)
         + toku_logsizeof_BYTESTRING(key);
}
uint32_t toku_logger_rollback_fsize_cmddeletemulti (FILENUM filenum, BYTESTRING min_key, BYTESTRING max_key, bool is_right_excl, uint32_t pm_status, bool is_resetting_op) {
  return 1 /* the cmd*/
         + 4 /* the int at the end saying the size */
         + toku_logsizeof_FILENUM(filenum)
         + toku_logsizeof_BYTESTRING(min_key)
         + toku_logsizeof_BYTESTRING(max_key)
         + toku_logsizeof_bool(is_right_excl)
         + toku_logsizeof_uint32_t(pm_status)
         + toku_logsizeof_bool(is_resetting_op);
}
uint32_t toku_logger_rollback_fsize_rollinclude (TXNID_PAIR xid, uint64_t num_nodes, BLOCKNUM spilled_head, BLOCKNUM spilled_tail) {
  return 1 /* the cmd*/
         + 4 /* the int at the end saying the size */
         + toku_logsizeof_TXNID_PAIR(xid)
         + toku_logsizeof_uint64_t(num_nodes)
         + toku_logsizeof_BLOCKNUM(spilled_head)
         + toku_logsizeof_BLOCKNUM(spilled_tail);
}
uint32_t toku_logger_rollback_fsize_load (FILENUM old_filenum, BYTESTRING new_iname) {
  return 1 /* the cmd*/
         + 4 /* the int at the end saying the size */
         + toku_logsizeof_FILENUM(old_filenum)
         + toku_logsizeof_BYTESTRING(new_iname);
}
uint32_t toku_logger_rollback_fsize_hot_index (FILENUMS hot_index_filenums) {
  return 1 /* the cmd*/
         + 4 /* the int at the end saying the size */
         + toku_logsizeof_FILENUMS(hot_index_filenums);
}
uint32_t toku_logger_rollback_fsize_dictionary_redirect (FILENUM old_filenum, FILENUM new_filenum) {
  return 1 /* the cmd*/
         + 4 /* the int at the end saying the size */
         + toku_logsizeof_FILENUM(old_filenum)
         + toku_logsizeof_FILENUM(new_filenum);
}
uint32_t toku_logger_rollback_fsize_cmdupdate (FILENUM filenum, BYTESTRING key) {
  return 1 /* the cmd*/
         + 4 /* the int at the end saying the size */
         + toku_logsizeof_FILENUM(filenum)
         + toku_logsizeof_BYTESTRING(key);
}
uint32_t toku_logger_rollback_fsize_cmdupdatebroadcast (FILENUM filenum, bool is_resetting_op) {
  return 1 /* the cmd*/
         + 4 /* the int at the end saying the size */
         + toku_logsizeof_FILENUM(filenum)
         + toku_logsizeof_bool(is_resetting_op);
}
uint32_t toku_logger_rollback_fsize_change_fdescriptor (FILENUM filenum, BYTESTRING old_descriptor) {
  return 1 /* the cmd*/
         + 4 /* the int at the end saying the size */
         + toku_logsizeof_FILENUM(filenum)
         + toku_logsizeof_BYTESTRING(old_descriptor);
}
uint32_t toku_logger_rollback_fsize(struct roll_entry *item){
  switch(item->cmd) {
    case RT_fdelete: return toku_logger_rollback_fsize_fdelete(item->u.fdelete.filenum);
    case RT_fcreate: return toku_logger_rollback_fsize_fcreate(item->u.fcreate.filenum, item->u.fcreate.iname);
    case RT_cmdinsert: return toku_logger_rollback_fsize_cmdinsert(item->u.cmdinsert.filenum, item->u.cmdinsert.key);
    case RT_cmdseqinsert: return toku_logger_rollback_fsize_cmdseqinsert(item->u.cmdseqinsert.filenum, item->u.cmdseqinsert.key);
    case RT_cmddelete: return toku_logger_rollback_fsize_cmddelete(item->u.cmddelete.filenum, item->u.cmddelete.key);
    case RT_cmddeletemulti: return toku_logger_rollback_fsize_cmddeletemulti(item->u.cmddeletemulti.filenum, item->u.cmddeletemulti.min_key, item->u.cmddeletemulti.max_key, item->u.cmddeletemulti.is_right_excl, item->u.cmddeletemulti.pm_status, item->u.cmddeletemulti.is_resetting_op);
    case RT_rollinclude: return toku_logger_rollback_fsize_rollinclude(item->u.rollinclude.xid, item->u.rollinclude.num_nodes, item->u.rollinclude.spilled_head, item->u.rollinclude.spilled_tail);
    case RT_load: return toku_logger_rollback_fsize_load(item->u.load.old_filenum, item->u.load.new_iname);
    case RT_hot_index: return toku_logger_rollback_fsize_hot_index(item->u.hot_index.hot_index_filenums);
    case RT_dictionary_redirect: return toku_logger_rollback_fsize_dictionary_redirect(item->u.dictionary_redirect.old_filenum, item->u.dictionary_redirect.new_filenum);
    case RT_cmdupdate: return toku_logger_rollback_fsize_cmdupdate(item->u.cmdupdate.filenum, item->u.cmdupdate.key);
    case RT_cmdupdatebroadcast: return toku_logger_rollback_fsize_cmdupdatebroadcast(item->u.cmdupdatebroadcast.filenum, item->u.cmdupdatebroadcast.is_resetting_op);
    case RT_change_fdescriptor: return toku_logger_rollback_fsize_change_fdescriptor(item->u.change_fdescriptor.filenum, item->u.change_fdescriptor.old_descriptor);
  }
  assert(0);
  return 0;
}
int toku_parse_rollback(unsigned char *buf, uint32_t n_bytes, struct roll_entry **itemp, MEMARENA ma) {
  assert(n_bytes>0);
  struct roll_entry *item;
  enum rt_cmd cmd = (enum rt_cmd)(buf[0]);
  size_t mem_needed;
  struct rbuf rc = {buf, n_bytes, 1};
  switch(cmd) {
  case RT_fdelete:
    mem_needed = sizeof(item->u.fdelete) + __builtin_offsetof(struct roll_entry, u.fdelete);
    CAST_FROM_VOIDP(item, malloc_in_memarena(ma, mem_needed));
    item->cmd = cmd;
    rbuf_ma_FILENUM(&rc, ma, &item->u.fdelete.filenum);
    *itemp = item;
    return 0;
  case RT_fcreate:
    mem_needed = sizeof(item->u.fcreate) + __builtin_offsetof(struct roll_entry, u.fcreate);
    CAST_FROM_VOIDP(item, malloc_in_memarena(ma, mem_needed));
    item->cmd = cmd;
    rbuf_ma_FILENUM(&rc, ma, &item->u.fcreate.filenum);
    rbuf_ma_BYTESTRING(&rc, ma, &item->u.fcreate.iname);
    *itemp = item;
    return 0;
  case RT_cmdinsert:
    mem_needed = sizeof(item->u.cmdinsert) + __builtin_offsetof(struct roll_entry, u.cmdinsert);
    CAST_FROM_VOIDP(item, malloc_in_memarena(ma, mem_needed));
    item->cmd = cmd;
    rbuf_ma_FILENUM(&rc, ma, &item->u.cmdinsert.filenum);
    rbuf_ma_BYTESTRING(&rc, ma, &item->u.cmdinsert.key);
    *itemp = item;
    return 0;
  case RT_cmdseqinsert:
    mem_needed = sizeof(item->u.cmdseqinsert) + __builtin_offsetof(struct roll_entry, u.cmdseqinsert);
    CAST_FROM_VOIDP(item, malloc_in_memarena(ma, mem_needed));
    item->cmd = cmd;
    rbuf_ma_FILENUM(&rc, ma, &item->u.cmdseqinsert.filenum);
    rbuf_ma_BYTESTRING(&rc, ma, &item->u.cmdseqinsert.key);
    *itemp = item;
    return 0;
  case RT_cmddelete:
    mem_needed = sizeof(item->u.cmddelete) + __builtin_offsetof(struct roll_entry, u.cmddelete);
    CAST_FROM_VOIDP(item, malloc_in_memarena(ma, mem_needed));
    item->cmd = cmd;
    rbuf_ma_FILENUM(&rc, ma, &item->u.cmddelete.filenum);
    rbuf_ma_BYTESTRING(&rc, ma, &item->u.cmddelete.key);
    *itemp = item;
    return 0;
  case RT_cmddeletemulti:
    mem_needed = sizeof(item->u.cmddeletemulti) + __builtin_offsetof(struct roll_entry, u.cmddeletemulti);
    CAST_FROM_VOIDP(item, malloc_in_memarena(ma, mem_needed));
    item->cmd = cmd;
    rbuf_ma_FILENUM(&rc, ma, &item->u.cmddeletemulti.filenum);
    rbuf_ma_BYTESTRING(&rc, ma, &item->u.cmddeletemulti.min_key);
    rbuf_ma_BYTESTRING(&rc, ma, &item->u.cmddeletemulti.max_key);
    rbuf_ma_bool(&rc, ma, &item->u.cmddeletemulti.is_right_excl);
    rbuf_ma_uint32_t(&rc, ma, &item->u.cmddeletemulti.pm_status);
    rbuf_ma_bool(&rc, ma, &item->u.cmddeletemulti.is_resetting_op);
    *itemp = item;
    return 0;
  case RT_rollinclude:
    mem_needed = sizeof(item->u.rollinclude) + __builtin_offsetof(struct roll_entry, u.rollinclude);
    CAST_FROM_VOIDP(item, malloc_in_memarena(ma, mem_needed));
    item->cmd = cmd;
    rbuf_ma_TXNID_PAIR(&rc, ma, &item->u.rollinclude.xid);
    rbuf_ma_uint64_t(&rc, ma, &item->u.rollinclude.num_nodes);
    rbuf_ma_BLOCKNUM(&rc, ma, &item->u.rollinclude.spilled_head);
    rbuf_ma_BLOCKNUM(&rc, ma, &item->u.rollinclude.spilled_tail);
    *itemp = item;
    return 0;
  case RT_load:
    mem_needed = sizeof(item->u.load) + __builtin_offsetof(struct roll_entry, u.load);
    CAST_FROM_VOIDP(item, malloc_in_memarena(ma, mem_needed));
    item->cmd = cmd;
    rbuf_ma_FILENUM(&rc, ma, &item->u.load.old_filenum);
    rbuf_ma_BYTESTRING(&rc, ma, &item->u.load.new_iname);
    *itemp = item;
    return 0;
  case RT_hot_index:
    mem_needed = sizeof(item->u.hot_index) + __builtin_offsetof(struct roll_entry, u.hot_index);
    CAST_FROM_VOIDP(item, malloc_in_memarena(ma, mem_needed));
    item->cmd = cmd;
    rbuf_ma_FILENUMS(&rc, ma, &item->u.hot_index.hot_index_filenums);
    *itemp = item;
    return 0;
  case RT_dictionary_redirect:
    mem_needed = sizeof(item->u.dictionary_redirect) + __builtin_offsetof(struct roll_entry, u.dictionary_redirect);
    CAST_FROM_VOIDP(item, malloc_in_memarena(ma, mem_needed));
    item->cmd = cmd;
    rbuf_ma_FILENUM(&rc, ma, &item->u.dictionary_redirect.old_filenum);
    rbuf_ma_FILENUM(&rc, ma, &item->u.dictionary_redirect.new_filenum);
    *itemp = item;
    return 0;
  case RT_cmdupdate:
    mem_needed = sizeof(item->u.cmdupdate) + __builtin_offsetof(struct roll_entry, u.cmdupdate);
    CAST_FROM_VOIDP(item, malloc_in_memarena(ma, mem_needed));
    item->cmd = cmd;
    rbuf_ma_FILENUM(&rc, ma, &item->u.cmdupdate.filenum);
    rbuf_ma_BYTESTRING(&rc, ma, &item->u.cmdupdate.key);
    *itemp = item;
    return 0;
  case RT_cmdupdatebroadcast:
    mem_needed = sizeof(item->u.cmdupdatebroadcast) + __builtin_offsetof(struct roll_entry, u.cmdupdatebroadcast);
    CAST_FROM_VOIDP(item, malloc_in_memarena(ma, mem_needed));
    item->cmd = cmd;
    rbuf_ma_FILENUM(&rc, ma, &item->u.cmdupdatebroadcast.filenum);
    rbuf_ma_bool(&rc, ma, &item->u.cmdupdatebroadcast.is_resetting_op);
    *itemp = item;
    return 0;
  case RT_change_fdescriptor:
    mem_needed = sizeof(item->u.change_fdescriptor) + __builtin_offsetof(struct roll_entry, u.change_fdescriptor);
    CAST_FROM_VOIDP(item, malloc_in_memarena(ma, mem_needed));
    item->cmd = cmd;
    rbuf_ma_FILENUM(&rc, ma, &item->u.change_fdescriptor.filenum);
    rbuf_ma_BYTESTRING(&rc, ma, &item->u.change_fdescriptor.old_descriptor);
    *itemp = item;
    return 0;
  }
  return EINVAL;
}
LSN toku_log_entry_get_lsn(struct log_entry *le) {
    return le->u.begin_checkpoint.lsn;
}
